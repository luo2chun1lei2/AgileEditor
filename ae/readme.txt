未来还计划制作可以设定相互依赖关系，并进行处理的工具，类似于scons！
建立通用的依赖和分析工具！ AgileRelation.

还有什么没做完：
-----------------

【下一阶段，努力将此编辑器变成类似Source Insight的工具，可以管理、分析、导引代码等】

* 整理服务和事件，形成统一、完整的命名体系，以及方便的注册和使用方案。
    事件是内部发生了变化后，引发外部组件的动作，因为不知道外部的组件，所以需要外部组件自己注册。
    服务是内部可以对外提供的功能，由外部组件调用此组件。
    外部组件怎么知道有此组件的事件和服务？如果认为组件是有层次的，那么上层就知道下层的组件。如果是用中介方案，那么组件都知道中介组件。
    所以从本质上说，必须有一方知道另外一方才能合作，不可能存在完全不知道对方的结构。
* VeiwMenu 没有做到完全自动化。还有动态加载组件导致的服务提供有先后的问题。
    menu知道component有多种方案：
    1，component知道有menu，注册时，将自己注册进去。menu必须在组件之前创建。
    2，menu知道有此组件（组件有标志），当注册此组件时，menu去检查组件是否有此标志。menu必须在组件之前创建。
    3，menu知道有此组件（组件有标志），当注册menu时，menu去检查之前所有组件是否有此标志。menu必须在所有其他组件之后创建。
    4，
* 动态加载组件，比如遍历一个列表或者文件夹，就可以加载所有的组件。
* 多个组件是否可以提供同一个服务？
* 代码浏览的工具换成基于clang的工具，参考 YouCompleteMe 这个vim的插件（http://valloric.github.io/YouCompleteMe/）。
* word complete 还是有许多的问题，比如会导致输入速度减慢，以及有许多的bug，和使用不方便的地方。
* ModelXxx 对象应该形成一组紧密合作的数据结构，然后对外发送实现，实现 MVC 模式。
* ViewFsTree 对于空目录和文件修改后，会出现问题！
* 应该将ViewWindow中对于编辑器的操作，放入到 ViewMultiEditors，然后将其中Search、Jump等操作都抽取成独立的组件。
* Ctrl+Y复制当前行，不用剪贴板，适用于“已经复制了一个单词，但是需要在目标文本中添加一个行，然后替换其中的一个单词”。
* 自定义快捷键，然后运行自编写的命令。可以将选中的文件和文字作为参数输入。
* 能够检索编译的结果，得到文件和行，自动定位。
* 编写特定的脚本，允许操纵整个编辑器，比如在特定的文件中加入特定的文字。
* bookmark记录的不是特定行，而是mark，这样即使修改这里文本之前的文字，也能标记此行。
* 建立更加独立的组件，此组件描述一定菜单、事件、信号、服务后就行了，不需要再添加control、view之类的组件。
  目前的组件体系还是复杂。

环境要求
--------

1，需要安装Python 2.6，用于Python语言。
2，需要安装PyGObject，用于使用Gnome控件（适用于Gnome 3.0）。
3，eclipse 4.4（Java开发环境），再安装PyDev。
4，需要安装id-utils，这部分实际上没有仔细的运行。
5, 请执行install_dev.sh

参考
----

1, Python GI API Reference:
    http://lazka.github.io/pgi-docs/
2, 本机代码参考：
    /usr/lib/python2.7/dist-packages/gi

3, gtk source view的语言分析
/usr/share/gtksourceview-2.0/language-specs

4，修改global的配置文件，加入需要避免的路径。
cp ./doc/global/examples/gtags.conf etc/
在common::skip中加入obj/

5, 快捷键参考 gdkkeysyms.h 中的GDK_KEY_XXX 设定。
  需要安装 libgtk-3-dev。
  
6, vim 的complete和代码分析用 YouCompleteMe(http://valloric.github.io/YouCompleteMe)，
  如果其不认识的语言用 omnifunc，此为完全补全工具，但是不如YCM是基于代码的分析得到补全信息。
  clang分析代码时，需要编译选项，GNU编译器参考 Bear(https://github.com/rizsotto/Bear).
  YCM内部的clang部分是用C++实现的，而不是用Python。
  有几个问题：1，补全功能实际上应该分析的是正在编辑的数据。
  2，代码分析也是一个重点。
  
  clang的python调用方法，参考
	Ubuntu 10.04 用 clang 3.8.
	http://blog.csdn.net/wangtua/article/details/77426883 clang的python接口（一） 
	http://blog.csdn.net/wangtua/article/details/78612331 clang的python接口教程（二）
	python的接口binding，在 “https://github.com/llvm-mirror/clang/tree/master/bindings/python/clang”，查看 cindex.py 文件就可以了，
	里面有说明。
	
	http://hao.jobbole.com/clang-static-analyzer/ Mac上的基于clang的静态代码检查工具(http://clang-analyzer.llvm.org/)。

  经过调查，目前只有YouCompleteMe是基于Clang的语法解析工具，但是
  1，不是独立的工具。
  2，不是用于代码分析的，是用于补齐(Complete)的，但是有 goto defination/reference这些功能。
  3，是C++编写的。
  现在可以实现的方案是根据YMC编写一个Server，然后利用IPC通信，获得各种信息。
	
	 
计划
----

开始进入结构调整期，在增加新的功能时，发现开发非常的不方便，应该将函数和组件的调用方法不断的剥离成
1，有一个主体结构，但是此结构下没有具体的功能。
1.1 主体结构以注册和消息分发机制为核心。
1.2 画面不是组合的，而是基于请求的，请求什么样的画面服务，就显示什么样的画面。
2，在此主体结构上，添加功能组件，称为组件。功能组件之间保持彼此之间的独立性。
2.1 组件之间不可见，而是通过发送消息的方式来处理。
2.2 组件可以分为画面、处理、数据和控制等类型，但是都是组件。
2.3 需要建立组件之间的依赖关系，需要保证组件之间的加载顺序。 依赖关系在安装和启动方面还是比较重要的。
3，实现：容易添加新的组件、修改组件内部的实现而不影响其他组件。
4，为以后扩展新的代码分析和界面处理而做准备。

设计的基础原理
---------------

设计不是凭空产生的，不是看了基本设计书后想实践而出的，也不是大家一起编写后就会自然生成的，
而是根据具体的需求，结合底层的技术实现方法，而且采取的最优化实现方式。
所以设计的第一步就是确定需求。

需求的原则
-----------

需求不是开发人员拍脑袋得到的，它来源于使用者的渴望。也许使用者一开始也无法说清楚，
可以通过原型、模拟、类比、参考来将这种说不清楚的东西搞明白。

另外需求是变化的，不是一成不变的，尤其是面对不同的用户时，甚至不同用户在不同的时期也有不同的需求，
设计人员需要将来自不同用户、不同时期的需求做一个整理，
分成不同的方面、时期和来源，然后按照重要性划分成不同的阶段，然后在每个阶段尽量将可以作为一个整体的需求放在一起，这样实现起来方便、规整。
最后根据上面的需求，然后选择设计架构。

AE的需求
---------

第一个阶段的AE已经实现了，当时没有特意的收集需求，毕竟使用者就是我自己，
想到什么就实现什么，所以主要的功能就是可以做成一个项目，然后包含若干代码，能够对代码进行分析和编辑。

实现了第一个阶段后，就遇到两个突出的问题，
第一个问题是程序挺复杂，代码也集中在三四个文件中，使用中出现了许多问题，虽然逐步解决了，
  但是感觉问题挺难分析，尤其是在停止开发一段实现后，再去看、调试代码时，常常不知道从哪里下手。
第二个问题是添加新功能时工作量大，比如添加一个检索的功能，发现在menu部分的几个函数中需要不断的代码，
  然后添加传递到window的函数，再在window中添加若干真正的功能，还有可能和其他的功能冲突。
两个问题实际上是一个问题，就是程序复杂了，无法像刚开始一样快速开发，而且随着开发推进，复杂没有收口反而不断的增大，
如果不修改的话，推测之后将进入无法维护的现实状况。

基于上面两个问题，提出了第二个阶段的主要需求：
1，对开发要提速，主要集中在画面、代码分析工具等二次开发上。
2，对调试和测试提出要求。
3，利用上面两个功能，快速的开发一些代码分析和第三方方便工具的模块。

框架怎么设计？
---------------

设计方案应该有效的降低系统的复杂程度，
其中一项就是代码的长度，越复杂，代码应该越多。
还有一项是修改代码或添加新功能的成本，越复杂，成本越高。

AE的框架设计
-------------

此框架的基础设计是基于“组件”结构，框架负责三件事情：
1，组件仓库(component repository)，负责启动的组件的实例管理，可以设计成池，需要实现生命周期。
2，组件加载器(component loader)，负责启动组件，对于灵活系统，组件可能需要从不同的来源获取，或者需要动态获知，所以加载器就不是简单的部分。
3，组件管理器(component manager)，建立在仓库和加载器基础上，是它们和由组件组成的程序之间的桥梁。
另外，还有一个组件系统，它是以组件为基本的组件形成的系统，此系统可以是完全由组件组成的，也可以重要和主要的功能由组件完成。

整个系统的运行原理是：比如组件系统发送一条请求，要新的组件，那么这条指令需要传递给组件管理器，管理器到组件仓库中查找，
如果已经创建且可以复用，那么就将组件返回，如果不可以，就通知组件加载器加载一个新的组件，注册到仓库后，
返回给组件系统的请求者。

组件在此基础上聚焦自己的功能，可以方便的编写和扩展组件。
此程序需要实现组件的注册、生命周期和运行环境(比如通信)。

为了实现组件的强约束，需要在组件的协同上，实现标准通信协议、标准组件，以及协作规范等等。

* 组件的作用是把功能拆分成多个模块，这样在复杂的、大规模代码的基础上可以容易的修改和增长，当然也容易删减功能。
* 服务注册机制是把原来功能是函数提供的，变成了基于“注册服务”来提供的，基于“注册服务”的调用方式好在
  必须提供运行时可以查的接口，以及明确的帮助和参数传递，这些都是可以动态组合的。当然，缺点是调用效率不高，
  这对于桌面应用来说已经够了。
* 通信管道作用是把基于组件或基于模块，反正基于层次结构的通信方式，变成了扁平的结构。
  解释一下，基于控件的方案中，想调用一个控件，必须找到上层的窗口、然后顺着窗口的包含策略一层一层的找下去，
  直到找到控件，然后再调用接口。如何复杂而且不高效的寻找机制下，通常的解决方案是将所有的控件（可能一开始只有少数，
  到了后期就基本上所有重要控件）都放到上层某个对象中引用，这样查找方便。不过对于跨窗口的功能和数据来说，
  这样就比较复杂了。还有一种方案是每个控件提供的功能都在上层实现接口可以调用，然后上层的上层又可以调用上层的接口，
  这个方案只在小的组合控件之类的实现过，对于大型应用程序来说实现成本过高，所以很难有程序这样去实现。
  
  那么“通信管道”这个方案，就是所有的模块如果需要通信的话，都注册到上面，可是实现“调用”和“回调”机制，
  还可以屏蔽服务提供方的类型和实现细节，是一个优美的设计。
  不过缺点是对于大型的应用来说，注册的组件会很多，如果不分组或者分层，那么查找的成本会变高。
  
  分组：在组件的注册和调用上，加入多级分组策略，"A.B.C"表示A组中的B组的C成员。因为分组，所以查找成本就会急剧下降。
  分层：每层都有自己的通信管道，然后允许和本层或者下层管道通信。
  分组和分层本质上并无不同，虽然实现的技术方法不一样。

组件的设计
-----------

组件的核心是：
	强替换性对象，普通对象技术虽然强调独立、内聚，但是指示思想，无法强力约束。
	然后以组件为基本单元组成“组件系统”。

促进组件化的设计，效果是每个功能有自己的组件，然后可以挂接在一起配合使用，在编写每个组件时，不用总是考虑其他组件的问题。
设计方案如下：
1，主体建立基本的注册、通信和协作机制，真正的功能组件都挂接在上面。
2，每个组件无论是按照什么方案划分的，都提供独立、完整、可以配合的功能。
   每个组件都是内聚的设定，它只要符合每个要求，都能完成自己的功能。
3，同一类型组件的不同实例需要提供可以区分调用的服务。

因为组件初始化有先后顺序，且有些组件是被其他组件生成的，所以这里需要考虑初始化的顺序问题。
比如有些组件向menu注册自己的菜单，那么就需要假定菜单在这些组件之前就被建立了，但是实际上，存在在menu之前创建的组件。
也就是说，存在组件可能需要在另外一个组件初始化后再初始化自己的情况。
解决方案有多种：
1，所有的组件都必须一起建立，对于无法事先建立的（比如view相关的），可以建立“代理组件”，此组件保存所有的请求，等到真正的对象建立的时候，
  再根据之前传递的信息建立这个对象。之后的请求就直接传递给此对象。
  缺点：无法实现动态组件，毕竟有些组件是运行时才决定的，或者加载的，无法在之前都建立起来。
  优点：框架实现简单。
2，建立严格的初始化先后顺序，如果发现服务不存在，立刻就出现错误。如果组件依赖于另外的组件，那么就需要在此之后初始化。
  缺点：无法实现真正的动态加载，另外严格的初始化顺序不一定实现，比如 menu 需要 dialog，dialog 也需要 menu，那么谁先谁后初始化？
3，组件在注册后，需要发送“服务已被注册”广播事件，比如menu通知“view.menu.add”服务上线了，需要注册自己菜单的，接到这个通知后，就注册。
  组件自己启动时，先查找是否存在“view.menu.add”服务，如果有再注册。
  优点：允许动态加载，无论先后顺序。
  缺点：组件的实现方式就比价复杂，需要允许重复发起请求。
4，从代理组件延伸，建立一套标准的接口，然后建立这些接口的组件实现，这些接口做为组件服务的中间层，屏蔽实现的细节。
  优点：可以规范实现。
  缺点：不利于扩展，再好的设计，也无法囊括未来所有的可能。

	如果是双盲组件，按照现实生活中的方法，应该是在具有“共同认识”的前提下，阅读对方组件的说明，
	然后分析如何使用，接着尝试调用是否正确。
	最后评测各种方案，得到最优的结果。
	
	所以建立中间、标准通信协议或组件是正确的实现方案，但是这种方案无法解决动态加载问题，只是解决了组件的通信标准问题。
	动态加载有一个“简单的实现”，
5，当后期每次加入一个组件后，就调用其他组件的“初始化”方法。组件的初始化方法必须是可以重入的。 <-- 目前是按照这样做的。
6，建立组件之间的依赖关系，然后按照顺序启动。 
  缺点：无法运行时，动态添加组件。
7，广播机制，但是一个服务注册的时候，就向所有的组件广播说“此服务实现了”，然后需要此服务的组件马上发出服务请求。
  缺点：组件的实现就会复杂，而且组件比较多时，加入一个组件的时间会很长。

组件是建立整个系统的基石，但是并不意味着所有的问题都要组件来解决，
许多问题是建立在组件基础上，再复杂化的设计，比如中间协议、层次划分等。

问题
----

1，在目前的架构中存在数据结构和画面、处理的区别，那么模型和算法在目前的框架中如何设计？
  面向对象的设计中，不区分数据结构和算法等，而是按照独立的功能划分不同的对象，每个对象都是包含数据和动能的一个独立个体，
  组件的设计方案也是如此，不能将整个系统划分为数据和画面，而是应该在底层按照独立性原则形成不同的组件，也就是更高级的对象，
  然后再组合成更更加高级的组件，对应不同层次的需求！
  结合AE这个项目，先划分层次，然后根据每个层次制定不同的组件划分，然后实现这些组件。
  在实践中，基于GUI控件、数据结构等已有的结构，组件将做出妥协。GUI控件必须相互之间包含，而且有些刷新、数据持有等动作都已经安排好了，
  那么控件想做成组件，实际上只需要把那些没有被GUI实现的功能做成组件对外提供的服务。
  
2，如何把功能都拆分出去？依据是什么？怎么作比较合理？
  按照基于对象的原理，应该将一个独立的功能做成一个对象，对象内部可以包含数据结构和对外的接口，屏蔽内部的实现机制和流程。
  如果对象内部的数据结构的细节需要暴露出去，那么这个设计就不够独立，如果内部的功能细节还需要外部了解才能使用，那么这个设计也是不够独立。
  应该在包裹的功能和数据基础上再建立更加高级的层次结构才是建立了独立的对象，也就是现在结构设计中的“组件”。
  
  反思一下菜单的设计，我想把菜单本身如何显示菜单、快捷方式等变成一个简单的接口：添加菜单，但是在实际的编写中发现，
  一个模块如果想添加菜单，不仅仅是调用一个“add”接口的问题，比如诸多菜单应该如何分组？点击了菜单后如何处理？
  我的思考是，菜单项目是有分组的，所以必须加入强的“规范”，作为菜单组件的一部分。
  至于点击菜单后的处理，不应该是菜单组件的一部分，菜单组件只能按照其他菜单请求显示的设定而发出被点击的信号，
  至于谁处理，应该是外部模块的机制，而不是菜单组件处理的。 那么谁处理？实际上，都是主窗口在处理，
  所以实际上应该是主窗口申请这个服务，然后自己根据菜单激活结果，注册具体如何实现！
  
3, 在 workshop中添加一个option，发现比较麻烦，要在workshop中添加数据项目，要修改设定文件的读写，
  然后修改 workshop preferences对话框，需要设定和显示同步，还要修改画面后修改设定。
  最后修改设定后，还需要找到方法修改所有已经打开的编辑器，那么之后打开编辑器也需要知道这个选项。
  在整个上面的流程中，其实可以用“链接”的方式，将画面显示控件、数据对象的字段以及文件的保存字段都对应起来，这样就省了很多的工作。
  这个就是“用关系维持对象一致”的设计方案。
  
4, 初始化整个体系崩塌，前提：
    a，目前无法将所有的组件都一起构造出来，需要虽然运行生成出来，比如有些组件内部又生成一些组件。(组合组件)
    b，无法预料到组件生成的先后，比如有些模块需要调用一些服务，但是这些服务所在的组件可能还没有生成，怎么办？（动态加载）
    c，某些组件可能在运行时被卸载，换成其他的组件。（动态替换）
  所以，可以如下设计：
    a，想要可以动态的启动、卸载、替换组件，必须松耦合，目前基于消息的请求服务模式是适合的。
    b，想要动态的启动，以及组合组件，那么请求服务就可能会出现先后问题，既然所有的功能是基于服务的，
      就应该基于服务来解决。如果加入新的服务，就发送“注册服务”信息，如果删除新的服务，也发送“注销服务”信息。
    c，因为服务是基于组件必须可以使用后的，所以服务注册应该在组件建立完整实例后进行。
      组件在注册自己服务后，发送自己的请求，无论此服务是否存在。然后监听“注册服务”事件，如果发现此服务有人注册，
      那么立刻请求自己的服务。  <-- 这个实现有点复杂，且比较困难实现的没有问题。是否暗示应该从命令方式转为描述方式。
    d，想减少复杂性的话，最好在开始就创建一些默认的组件，但是这样就违反了“组件替换”的需求。
    --> 目前没有好的方案，就是在在run之前建立FwManage的实例，然后在run之前调用register，之后都调用了load，
        如何从根本上解决这个问题，需要再思考！

5, 消息机制除了注册对外提供的服务后，还需要提供消息和监听机制。
  比如有些控件，它在某些动作下会引起事件，但是此事件并不应该由它处理，所以它发出事件后，
  其他的组件应该监听此事件，然后做出处理。
  
  消息和服务是否是同一件事情的两种不同的实现方案？ 
  从技术上说，是！因为发送信息还是调用服务，其实都是调用。
  从意义和扩展性来说，不是！
    组件提供的服务，是不知道什么时候应该调用，但是知道应该做些什么，
    而提供的时间，则是知道什么时候发生了什么，但是不知道应该做些什么。
  比如一个菜单上点击了一个“关闭文件”按钮，但是菜单不知道要做什么，它只是发出一个event。
  注册监听“关闭文件”事件的ViewWindow接到信号后，就关闭当前文件。
  但是现在修改成了菜单就直接调用服务！那么它需要知道都有什么组件可以调用“关闭文件”服务。
  这个就不好维护了。事件模型中，谁想知道这件事，就自己注册监听。
  服务是告诉别人我可以干什么！
  
  目前的事件添加机制，没有一个统一的地方注册都有什么事件！以及事件的意义是什么！参数是什么！
  虽然这样比较严格，但是能够发现不符合要求的事件提供者，这样是否更好？
  
6, 目前碰到严重的问题，就是事件机制和服务机制两个机制机理是重复的，只是在意义上不同，
  现在有三条路可以做，一个是都修改成服务机制，另外一个是都修改成事件机制，
  第三个是根据不同的目的采用事件或者服务机制。
  
  下面讨论：
  其实参考GUI的设计方案，是保留两种机制的，首先所有的控件都有自己的对外接口，这就是服务机制，
  所有的控件又都有事件机制，凡是可以注册的模块都可以注册如何应对发生的事件。
  回到这个项目，Menu就应该提供加入MenuItem的功能，然后对外提供被按下的功能。
  虽然menu可以直接调用菜单对应的功能，那么就无法做到独立。
  数据模型如果被修改了，那么需要向外发出信号，如果有View再监视这些数据的变化。
  或者加入Control组件，它接到事件后，整体变化数据模型和View。
  *总之，整体的设计就是：有组件发出信号（它不负责处理），有组件负责接收信号，然后调用服务，满足事件的需求。*
  
  最终的想法是，建立Control组件，负责监听各种UI事件，然后修改Model模块，Model被修改后，
  发出模型事件，View和Storage之类的模块都监听模型的事件，然后根据模型做出修改。

7, 组件内部可以生成外部需要的实例，比如view类型的组件，这种怎么办？
  a，实现工厂组件，此工厂组件可以根据需要生成特定的组件。
  b，还有的组件自己本身就是一个view，那么就创建多个组件，然后提供给不同的部分来实现。
  
8，比如有一个terminal组件，它可能被用于不同的用途，但是服务只有一个。怎么办？  【重点研究的问题】
  a，【转接服务消息器】
    就是可以拦截一个组件发出的消息，以及将此组件的调用转换为另外一种形式，这样就可以将多个组件组合成一个新组件。
  b，转发消息时，添加组件名字，或者和组件约定好一个标志，虽然组件是一个实例，但是服务提供不同的结果。
  c，创建组件时，创建不同的参数，然后组件创建的服务名字也变动，
      比如 “model.file.cut”就变成“model.<file name>.cut”，这样同类型的组件可以提供不同的实例和不同的服务了。
  d，将服务变成消息类型。比如创建一个组件，从外部将其注册在不同的消息上，消息的类型是相同的，
      然后组件获取到消息后，只要是自己可以处理类型的就行。而发出消息的，则需要区分同类型不同具体用途的消息。
      首先，UI知道做什么，但是怎么做，不清楚。其次，底层的组件知道怎么做，但是不知道怎么做。
      实际的工作应该是开发组件的人员不必知道谁调用它，而由更高层次的组件负责管理它们。
      但是基于服务的模式，导致所有同类型的组件都使用一个服务，所以同类型的组件只能是同一份数据的不同副本，
      而不能是同一个类型组件的不同用途的实例，这样的设计将一种设计图景抛弃了。
      
9，全新的结构：
	1，目标:
		a，是更加方便、独立、灵活的开发。组件的复用性和可维护加强。
	2，思路：
		a，系统结构分成不同的层次，底层只提供最简单的服务和事件。而更加高层的提供更高层的服务。
		   注意，除了最底层的结构，每层结构实际上都是下一层组件提供的，也就是说这是低层组件向高层组件提供服务的一个结构。
		b，每个组件只需要知道自己要什么，和对外提供什么。组件是基于描述的，由其他的组件负责实现具体的描述。
		c，每种组件可以创建多个实例，分别对不同的目标进行类似的工作。
		d，同一个服务可以由不同组件来实现，用户或者系统可以挑选最合适的实现，也可以动态的切换。
		e，组件是动态加载和卸载的。每个组件加载或者卸载后，系统都要处于正常运行的状态。
	3，模型通论：
		0，建立模型，制定需求，然后看所有允许输入是否都满足需求。
			还可以根据需求，看什么样的模型能够满足要求。
			或者建立了模型后，根据输入，看会产生什么样的结果。
		1，系统中任何一个研究目标都是一个对象，用小写表示，后面可以加类型，比如 c1:C1，表示 c1 对象是 C1 类型的。
			复数表示集合，单数表示其中之一。
		2，{} 表示有名字的对象集合，允许重复，[]表示无序集合，不允许重复，<> 表示有顺序的序列，可重复。
			() 表示当什么发生，或者什么为真时，比如 f(x==5)，表示 “x==5” 成立时，会引发 f 动作。 f(x)，表示“只要x存在，就有动作f”。
			<< 表示"导致、变成"，是单向的动作，不是关系，用来代表“当发生了什么后，导致了什么结果”，上面也可以表示为 “(x==5) >> f”
			<= 单向赋值，单向关系，比如 x <= 5，表示“x变成了5”，或者“5赋值给x”，反过来不能说 5 就是 x。
			= 就是等同关系，表示系统一定要符合的关系，可以用 = 的一边代表另外一边。
			其他的遵守逻辑表达符号。
		3，动作 action 用一个函数来表示，比如 f(x)，x是动作发生的时机。
			比如 foo(x==5)，表示当x是5时会引发foo动作，或者表示为 (x==5) >> foo。
			f = [ y <= x ]，表示f的具体动作是“将y从任何值变成现在x的值”，方括号中可以写任意多和任意的语句。
			可以表示为 (x==5) >> [y <= x]。
		4，每个对象可以具有任意的状态，比如 c1.states = [none, unregistered, registered]
			[ (c1.state == states.none and c1.new) >> c1.state <= unregistered,
			  (c1.state == states.unregistered and c1.register) >> c1.state <= registered,
			  (c1.state == states.registered and c1.unregister) >> c1.state <= unregistered,
			  (c1.state == states.* and c1.delete) >> c1.state <= none ]
		5，每个动作有两个方面，一个是实际会做什么，从此可以推断出系统真实的运行情况，另外一个是想做什么，
			这个用于诊断系统的结构是否真的符合要求。这两个一定要分明。
			f = <f1, f2, f3> 是描述实际怎么实现， f >> a <= 3，描述的是期望。
		6，评价
			u(s) 是针对系统s的评价函数，多个u函数必须满足一定的条件。比如 u1 代表系统反应时间，u1(cn.action) < 200ms，
			表示“任何组件实例的动作反应时间都必须必须小于200ms”。条件用 cond1 = u1 < 200ms。
			系统需要达成的功能: requires(s) = cond1 and cond2 and cond3，是 s 必须满足的条件集合。
			需求不一定是静态的，也可以是动态的，就是在输入一些动作序列后改变。
		6，系统是否可以完成功能，是由其结构决定的。S = [f1, f2, f3, f4]
			注意这个是静态的，是系统运行的指导。
		7，系统建立后，会存在内部的运行序列，以及外部的事件序列，都可以用动作序列来表示
			SEQ = <f1, f2, f3, ...>
			当seq影响S时，会产生一个系统队列
			S = <s1, s2, s3, ...>，其中 f1 >> s <= s1，f2 >> s<=s2，以此类推。
			无论这个队列任何元素，都应该满足系统的要求： requires(s) = True。
		8，对象的动作的结果由子动作来实现，那么也可以根据子动作来分析是否满足了需要。
			<f1> >> [s <= s1 and (requires(s1) == True)]，对于任意f序列，都要s变成s1，且s1符合条件requires。
		问题：条件成立 "f >> (r(s) == true)"，和条件是True "f >> r(s) = true"，以及 "f >> r(s) <= true" 是一回事吗？
			""
	4，当前模型：
		1，每种组件命名为 Cn，可以拥有多个操作。比如 C1.actions = {new, delete, register, unregister, do_something, ...}
			状态 C1.states = {none, unregistered, registered}
			[ (c1.state == states.none and c1.new) >> c1.state <= unregistered,
			  (c1.state == states.unregistered and c1.register) >> c1.state <= registered,
			  (c1.state == states.registered and c1.unregister) >> c1.state <= unregistered,
			  (c1.state == states.* and c1.delete) >> c1.state <= none ]
		2，每种组件可以生成多个实例，cn:Cn，必须是 new 生成的， C1.new >> c1 <= C1.new
		3，假定有 c:C.do1 >> (c:Menu.know(c1) == True)，一个组件如果有do1动作，此动作会导致所有Menu类型的实例都知道 c1。
			动作实现 c:C.do1 = [ c:Menu.add(c1) ]，那么分析动作实现是否可以达到目的。
			但是因为 c:Menu可以unregister，然后再 create，register 一个 c:Menu 时，则 (c:Menu.know(c1) == False)。
			所以错误！
		6，生成可能的序列 seq1 = <c1<=C1.new, c1.reg, c1.unreg, ...>，然后看结果是否符合要求。
		

总结
----

1，将ViewBookmarks涉及的功能拿到外部，核心的主体是将bookmark的功能从ViewWindow中拿出，
  因为bookmark涉及到Window的一些内部的功能，比如make_book，这个需要了解内部编辑器的细节，
  所以我在这里做了分层，将涉及到window和编辑器的功能还保留在window中，然后将“动作”和“主要处理流程”
  都迁移到 ViewBookmarks 中。
  
2, 通过构建组件，形成了services，而services则提供最具体的实现，比如GUI、Storage等操作。
   不论是组件还是具体实现都是为了形成service，service机制上又形成了“有中心的网络结构”。
   这个结构就是service的事件发送给中心，然后由中心再发送到周围的节点处理。 原来的中心是 ViewWindow，所以这个类才那么多的代码。
   
   不过在这里模型中，没有看到 MVC 的结构，对于有复杂的、强关联的数据模型的程序来说，MVC 还是相当实用的！
   目前我将Control当做中心，Model之外的事件（来自于View或什么，这里的View指代Control和Model之外其他所有的模块）都先修改Model，
   然后Model修改后，发出消息给Control，Control再发给View！