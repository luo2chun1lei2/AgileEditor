# Agile Relation Editor

## 原则

不要人为复杂化！对于功能的最直接实现。
最好的设计是：底层以独立、原子的功能，顶层一个用户可用接口，中层是粘合结构。
有目标，才有计划，去实施才能实现。

## 其他工具

1. sudo pip install prompt_toolkit 需要升级到 2.0.9 以上。
  用于命令行提示输入的工具。
1. sudo pip install CodernityDB
  这个是 Python 语言开发的，嵌入到程序中的NoSQL DB，是 key-value 类型。【目前还没有真正使用】
  
## 纯粹数据关系的设想

一个系统可以描述各种对象之间的关系，然后
1. 根据对象、关系的进行查询、重新整理，找到解决问题的方法。
2. 将描述中的关系设定特定的表现方式，然后表现出来。比如，汽车有车轮，“有”就设置上表现的标签“包含”，这样就显示出来。
   或者设置成UML的表现标签，这样也能用UML显示出来。
3. 让系统运行起来，赋予关系以某种计算或运行的意义，这样可以静态的看到最终结果，或者动态的看到运行状态，以及某个时间点的状态。

关系 -> 解释 -> 分析 -> 解决问题

## 设想利用关系来开发应用（不仅仅是数据关系）

1. 元素关系描述数据关系，可以对这个数据关系进行管理(insert/delete/change/select)。
2. 元素关系是蓝图（blueprint），相当于结构描述，程序根据蓝图可以组成应用。
    组装后的程序自行运行，运行的内部调用还是Python之间的调用。
    当改变蓝图，就同时改变应用的结构。
3. 元素关系就是一切，每个特殊的元素都是特定的模块，关系来设定这些模块的组成方式和通信方法。
    模块之间的通信都通过关系来传递（就像fidl）。这样元素关系就是应用，应用就是元素关系。

关系 -> 解释 -> 组装 -> 执行

下面开始第一阶段的设计和实现。

## 设计原型

用特定的语法描述元素和它们之间的关系，然后可以显示、查询和编辑。
需要符合我个人对于这个世界的各种理解方法：
1. 所有的事物都称为“对象”(Element，不用object因为python中有object)。
  对象具有类别（类别也是对象），同样类别的对象具有类制定的行为逻辑和特征值。
  此软件可以根据类别建立具体对象，这有点像是模板。
2. 对象之间用特殊对象，称为“关系”（Relation）相连。
  可以建立对象之间的联系，并进行设定。比如“继承”、“拥有”。
3. 建立了关系的对象全体，从意义上说是完整的，那么可以称为“模型”（Model）。
  建立后的模型，可以进行显示、查询和修改。
  并且可以根据模型分析和运行。【这个非常的重要】
4. 对象之间可以不断的转换，是动态的。然后根据公式或者分析方法，演变成静态的关系公式。
  此软件可分析模型，并根据设定好的分析工具，分析关系和对象，变化成新的模型。
  【这里是我的不同于数学的构思，就是模型本该是动态的，而不只限于静态的描述关系，
    因为之前人类只能使用纸和笔，无法制作动态变化的模型，现在有了计算机，就可以了】
  
## 综合后的具体要求

0. 不用重复发明车轮，如果已经有好的实现就用，没有必要为了炫耀自己的技巧去实现一些东西。
  意思就是有现成的模块可用，就用，不要自己再实现了。
1. 可以录入数据，能够符合大多数数据的要求。比如带有属性的对象，然后描述对象和对象之间的关系。
2. 可以以人的思维视角，去查询、改变数据。
  用命令查询关系。人容易理解的查询语句，而不是SQL、Python脚本之类基于底层实现的。
  就是按照人对一个事情的理解，可能会存在模糊和矛盾的地方，可以进行提示。
  比如可视化操作，或者更加容易的操作。
  比如上一次的脚本存下来，对于结果和初始条件可以很容易的修改，边修改边看到答案。
  可以通过描述要什么，而由程序自己选择算法来实现。
  比如我想去A，那么到A的途径就由程序来设计。这个不是安排好的算法，而是用AI进行启发的解决。
3. 用户建立了基本的模型(model)后，可以针对模型进行各种分析和处理。
  1. 最简单的分析就是检索模型中的某些类型的数据或者特定的元素。
    然后再根据检索的结果，显示某个方面，比如显示为关系图，或者类图等等。
  2. 处理就复杂多了，可以添加更加复杂的数据，也可以减少和修改。
4. 数据可以有不同的来源，可以是
  1. 特定的python脚本文件，直接调用内部的model、control的接口。
  2. 是内部的script脚本，通过parse、control解析后，调用model的函数。
  3. 可以是数据文件，被反序列化后，直接形成model数据。
  4. 来自命令行的要求，这里允许简单的数据输入，然后就可以形成简单的模型，方便马上验证想法和测试。
    总结一下来源： command line, inner script(各种), serialized data, invoke inner API.
    所以就要求，程序允许接受各种输入，这个不是故意复杂化，而是因为测试和实际开发的需要。
    另外，这里说的是数据的来源，并不包括所有的外部输入，比如操控多个模型的命令。
5. 对于程序的控制：
  1. 模型的数据最好是模型自己控制输入，而不再需要其他模块负责，因为数据本身已经很复杂了，再复制接口是没有必要的。
  2. 对于模型的各种遍历和分析处理。
  3. 对于多个模型的处理，比如合并、转化等。
  4. 对于程序的处理，必须启动、关闭、交互等。

目前想用到的应用场景是：数据分析（彩票统计等）、程序关系（调用关系、静态关系等）、逻辑分析关系等。
  
## 设计方案中的概念

1. 元素(element)是此程序中所有的对象的统称。
  1. 元素必须具有唯一的内部ID，这样方便定位和查找和保存。
2. 关系(relation)是元素之间的关系，实例必须关联两个以上对象。需要强调的是，关系也是元素。
  建立关系时，关系涉及到的元素和关系本身都需要验证是否符合要求，否则关系无法确立。
  1. 属性(property)是一种特殊关系。
   指依附于某个元素的元素，当属性依附的元素消失时，则属性消失。这个是简化“两个元素以属性关系相关”的说法。
  2. 包含(contain)是说：容器持有其他元素的引用，可以检索、移入移出被包含的元素。
   被包含的元素没有必要是同一个类型的。
  3. 类型（Kind）是两个元素之间的关系。
   一个元素1是另外一个元素2的类型，那么就是说元素2满足元素1的所有要求，但是元素2不是1，是1的实例化。
   在目前编程语言中，class是典型的类型，一般是元素1规定了需要实现的field和method，而元素2必须按照实现和使用。
   【一定要类型的原因是，模型如果涉及到大量的元素和关系，必然需要一个模板来统一生成和进行操作，这样才能作统一的处理，
    那么关系也可以针对“类型”，这样试用的范围也就广了】
   1. 为了方便使用。针对添加类型，元素可以按照类型衍生出来。
    类型和元素之间的关系是“衍生”，正向和反向的称呼不同。
    类到元素是衍生，元素到类是继承。
3. 基本元素(basic Element)
  1. 这里的元素先排除 Relation。
  2. 其他的元素可以是 类型、实例、功能。
  3. 类型是说：这个元素是具体元素的描述。不过它可以用于表述此类型的实例都是如何运行的。
    类型不是集合，而是特征描述，python的对象就是这个概念。
  4. 实例是说：类型下的具体例子，如果没有特殊的地方，那么就不需要特殊的说明。比如统合所有名字的管理实例，
    这里强调所有地方都必须用这一个。
  5. 功能：这个是纯粹的运行逻辑，可能需要外部的实例。
4. 基本的关系(basic relation)
  1. 只有在一个规定的系统中，才能说关系。目前比较常用的我提出：类型、持有、依赖。
  2. 类型是说，一个对象是另一个对象的描述或抽象说明。在程序中就是"类"和"实例"。
  3. "持有"是说，一个对象拥有另外一个对象，所以当此对象生成或销毁时，另外一个对象也同时生成和销毁。
   比较常见的是实例和成员的关系。但是在实际的编程中，实例的成员有可能是另外一个独立的对象，并不随着实例生成和销毁。
  4. "依赖"是说，一个对象需要另外一个对象，可能是调用、使用等更加细分的关系，但是总之是依赖。
   “持有”和“依赖”两个在编程中比较含糊，虽然实际编程中却很重要，因为涉及到资源的申请和释放，或者状态的保存等等。
   我的希望是，之后延伸出来的关系，都是在这三个关系的基础上衍生出来的（目前没有哲学或者说数学的根据），
   需要在实践中不断的尝试和微调，当然我也希望能够从某种理论上获取正确的分析。
5. 由关系到表现，是基本关系 -> 基本表现。对于复杂一些的系统有如下的想法，
  1. 衍生关系 -> 基本关系 -> 基本表现，好处是无论什么衍生关系，都可以表现出来。
  2. 衍生关系 -> 衍生表现 -> 基本表现，好处是可以直接对应复杂的output
6. 类型和实例
  类型 -------> 关系类型
   ^--+          ^--+
  元素实例 ----> 关系实例


## 具体的实现：

因为目前实现起来，非常的复杂和混乱，所以下面的全部都推翻，重新整理。

0. input是输入，可以是view、console、Text等。output是输出，可以是view。
1. Model：
    1. 包含一个完整的元素和关系，提供 register event/callback method 接口，
        以及遍历和分析接口。 
    2. Element是基本的数据结构，包含Relation。
    3. Element和Relation的设计和实现
        Relation和Element之间功能的切分一定要清晰，因为目前没有多少实现的经验，所以还不知道怎么设计。
    4. Model需要提供给外部一直的接口，【这里有疑问，如果model数据的输入格式和来源不同，那么Model怎么处理？】
2. mvc层，包含Control + Model + View，功能主要是：
    1. Control，是对MV的控制，但是只能控制配对Model。
        可以接受外部的命令包，然后针对MVC层进行处理，不负责具体的Model的处理，
        可以将外部的数据处理传入到Model来处理。
        Control 就是 Executor ！
    2. View 是模型数据的表现，可以是显示的界面，日志输出，或者是文件。
        View可以是多个，这个都由Pipe来决定。
        View将输入的信息也变成标准命令，然后交给Executor来执行。
3. Executor，负责将标准的model命令，变成对于Model的调用。
    当Model支持的函数不同时，Executor负责转接。
    当Model的标准命令的版本不同时，Executor负责转接。
4. Parser，负责将各种输入，转化为标准的model命令。Parser可以是各种来源（GUI、Console、Script）或者
    各种命令格式（简单的命令、复杂脚本语言等）。
    1. Parser：负责将传入的输入导入到
        负责分析传入的命令，变成命令包(command package)，自己执行，或者发送给更下层的Control。
5. Pipe层，功能主要是
    1. Processor: 容纳一个MVC实例，这样就允许App同时有不同的 Model。【目前不允许MVC之间交互】
6. App层，建立基本的程序运行结构，包括建立 input/parser/executor/model/view 模式。
    【这样设计的方案是，主要是建立命令执行和交互执行两种模式Mode】
    1. 解释命令行，然后创建 Parser + Container 模型，这样就建立基本的运行机制。
    2. 将“交互界面”的输入和Parser连接在一起。
7. 如果有多个Parser需要协同怎么办？简单的实现就是Parser1对于委托分析的就调用Parser2。
   如果有多个Executor怎么办？一个是Pipe可以有多个Executor，命令必须是区分的。另外一个是多个Pipe，每个pipe一对parser和executor，但是input是一个。

为了让命令更加有通用性：
command text --------> command standard package ----------------> model
              parser                                executor

所以需要“输入、分析、执行模型”（IPE）:【只是最基本的处理流程】
input --> parser --------> Executor ---> Model ---> output
各种输入   分析输入得到命令     处理命令       改变模型     输出（view或者序列化）

Executor/Model/Output = Control/Model/View：
Control(=Executor) ---> Model --> Output(View/Storage)

那么需要 Subject-Observer模式，建立Model和View之间的关系。

这里需要Control能够将 Parser/Executor 和 Model 连接起来：
Parser --> Executor --> Model

基本的程序结构
        App/Container --> MVC ----------> Parser/Executor/Model  -----> Output
input >>----程序相关--------控制Model----------模型相关 -------------------输出相关的
[这样在Executor处，就可以建立command history，这样可以回滚、重播和找错]

所有数据转化流程：
                                        [parser]       [executor]
cmd line/interview cmd  ----> model script --> command package --> model method ----> model <----> serialized data/View
                         \--> control app/mvc
                           [parser]

核心的是两条：
1. 根据 “输入、分析、执行、模型、输出” 为一条核心执行设计线索。
2. 根据 ”控制(输入、分析、执行） -> 模型 -> View“ 的模式，是核心的架构。
    两个设计架构是结合在一起的。 执行就是控制，输出就是View。

===========================================
重新设计：
* 因为整个项目的目标过于复杂，所以想建立几个Level，从简单到复杂来规划实现，
 Level0是最简单和本质的实现，然后不断向更加复杂的方向延伸。
 
1. Level1：实现Element和Relation基本的功能，
  简单的Model容器，可以容纳和查找。
2. Level2：Element的扩展有”类型“和”实例“，可以根据类型创建实例。Relation则有”拥有“和“关联”。
  Model可以挂接外部的输入、控制和输出。
3. Level3：Element和Relation的各种扩展，允许元素和关系之间的组合和衍生。
  Model可以用于静态分析和动态运行。

## 实现的注意点

1. 设计成以上结构，是方便替换实现方法，但是会需要程序设计的非常精巧，这个尽量采用简单的实现方案吧。
2. 显示、存储需要和数据模型尽量分离开，因为这个程序的核心是“数据”，如何显示和怎么保存都会灵活变化。
3. 起点不妨高一些，建立“领域语言”，并且可以进行编程。
   领域语言不一定是独立的解释、编译语言，可以是建立在某种特殊方法（比如早期建立在C的宏基础上的objective-c语言），
   或者就是一个复杂的类库，这样就不需要建立额外的语法了。
   
## 用户使用说明

### 启动命令

rlt --execute <script file>
rlt --interview

进入交互模式后，可以执行命令
命令可以是下面几类：
0. execute <script file>，脚本文件中可以包含下面所有的种类。
1. app 管理应用程序 （$xxx）
2. processor 管理内部的处理 (!xxx)
3. model 针对MVC中的M，当然需要通过parser解析 (xxx)

### 模型描述

建立的类似于普通应用程序中类型和变量，没有函数。
函数在程序中是执行序列，而关系是静态描述。

Kind Child from Person:
    name, age, sex
    Study

Kind School:
    name, location
    Teach

Relation Study/Teach(School, Child):
    id

School(”罗一“, "13", "男") as luo_1 
School("11中") as school_11
Study(school_11, luo_1)


## 进度(要尽快！！！不要磨蹭，抓住空闲时间！)：

1. -建立基本的运行结构，只要能够运行起来。-
2. -命令解析，放在后面做。仿效git的命令方式。-
3. 目前的重点是数据的结构。
  -1. 测试驱动：先写好需要执行的脚本，和产生的效果，然后再实现真正的逻辑。-
4. 如果想建立统一的关系后，用任意UML图显示，那么就先要建立统一的UML关系。
  -1. package/component/module/class/field or method-
  -1. 要不要考虑二级模型转化机制，就是一个通用的关系系统，然后将此关系系统转换成UML描述的关系，最后转换为显示的图。
   不过这个比较麻烦。目前编程语言是通过"对象继承"来实现复杂类型关系的，而转换则需要太多的层次结构，实现比较麻烦。
   另外一种方案是建立通用关系的定义，然后在此基础上建立更加具体和UML定义，用这个具体定义去描述系统，
   最后再生成UML。【目前是按照第二个方案进行的】-
  -1. 活动图和序列图都应该描述“函数”和“函数”之间的关系。-
  -1. 实现新的Input，只需要简单的控制台，不需要 prompt_toolkit。-但是家里的控制台无法使用这些，不知道为什么？
  -1. 建立简单对象之间的关系。（不是UML）-
  -1. 模块越来愈多，如何组合，谁和谁组合，以及他们之间的一致接口很重要。
   组合方式用“脚本”来描述如何？而不是通过复杂的命令行参数，这个会导致复杂程序命令说明。
   目前Model和Parser、Executor、Output是捆绑在一起的，如果无法从一致的语法进行扩展，那么只能是一套系统就是一套。
   这样的话，可以用 processor的名字代替整个一套的名字。-
  -1. ae_rlt -m basic -i 的 !xxx 命令不认识。-
  -1. 显示正确的帮助。-
  -1. script中不支持换行！- 实现的比较复杂，以后有机会还需要重构。
  -1. 基本模型的基本关系有几种？这里需要设定一下。-
  -1. interactive模式下，script无效。-
  1. 基础模型或者是其他模型，对于同一类的对象，缺少特殊的标签。或者说生成的图像无法突出的表现出重点的元素。用颜色？
  1. process可以通过注册，或者config配置来组合，或者其他
   1. 我怎么知道目前有哪些processor？
  1. 允许使用简单的语句就可以实现 关系的描述，包括UML的。现在的语法太复杂和难以描写。
  1. 高级的模型可以用简单的模型通过扩展来实现，这个扩展开始可以是一个python的类，之后可能是通过脚本来扩展。
  1. 通过数据文件，加载model。
  1. 去掉目前可以解决的TODO。
  1. 模型中有许多包含关系，如果只是用线表示，很不清晰。 因为Graphivz的subgraph功能非常的简陋，且按照关系分析非常复杂，目前无法实现。
  
新任务列表
1. Level1
  1. 最基本的Element和Relation。
  2. 最简单的Model。
2. Level2
3. Level3

## 琐碎记录：

如果建立比较通用的关系后，想建立更加具体或者复杂的关系，比如UML，那么应该建立某种更高级的规则，来描述 关系A=关系B+关系C之类的。
比如A是B的父类，B是C的父类，那么A也是C的父类。诸如此类。

1. 最基本的是“拥有”关系，比如"B--have-->foo"，就是“B拥有foo”。如果关系没有写就是缺省。
  关系有方向性，有前后关系。
2. 其他关系： A--调用-->B，是“A 调用 B”。
3. 组合关系： “A调用了B的foo函数” = ”B拥有foo函数，而A调用了foo“，如果再深究的话，那么A是无法直接调用函数的，所以”A拥有的bar和B拥有的foo函数之间是调用关系“。
  组合关系是说，将一些关系的组合，变成一个关系的统称。反过来，可以根据一个关系的统称，转化为一组关系。这个符合现代语言的定义。

就是说，以目前的情况看，不断扩展python的类比较困难，也不是长久之策，最好是允许在脚本中扩展类型。但是

1. 扩展类型可以，但是扩展类型具有的特定实现就很难。因为目前显示类图的工具不是简单的在graphiv上组合得到的。
2. 类型扩展目前受制于 UML 本身。
3. 最好是允许扩展“类型”，然后还可以针对特定的类型，指定的特定的实现。

pipe的结构挺好，但是怎么实现？
1. pipe可能是临时的，比如在运行交互输入时，中间想执行一个脚本。那么这就同时有两个pipe，因为输入不同，所以Model和Executor一样。
    那么Executor是否可以同时运行在两个pipe中？
    回答：pipe必须能够允许其中的模块可以被其他的pipe同时顺次使用。
        可以临时的创建一个Pipe，然后进行处理。完成后就销毁。
2. pipe的概念是否太重？在普通的程序设计中，各个模块直接调用是否就行了？
    回答：不是，因为在app中存在调用这些模块的大量代码，这就是pipe应该存在的例证。



