还有什么没做完：
-----------------

a, VeiwMenu 没有做到完全自动化。还有动态加载组件导致的服务提供有先后的问题。
b, 动态加载组件，比如遍历一个列表或者文件夹，就可以加载所有的组件。
c, 多个组件是否可以提供同一个服务？
e, 代码浏览的工具换成基于clang的工具，参考 YouCompleteMe 这个vim的插件（http://valloric.github.io/YouCompleteMe/）。
f, word complete 还是有许多的问题，比如会导致输入速度减慢，以及有许多的bug，和使用不方便的地方。
g, Model* 对象应该形成一组紧密合作的数据结构，然后对外发送实现，实现 MVC 模式。
h, ViewFsTree 对于空目录和文件修改后，会出现问题！
i, 所有打开的文件都关闭后，右边的文件tag会出现问题。
j, 应该将ViewWindow中对于编辑器的操作，放入到 ViewMultiEditors，然后将其中Search、Jump等操作都抽取成独立的组件。
k, 整理服务和事件，形成统一、完整的命名体系，以及方便的注册和使用方案。

环境要求
--------

1，需要安装Python 2.6，用于Python语言。
2，需要安装PyGObject，用于使用Gnome控件（适用于Gnome 3.0）。
3，eclipse 4.4（Java开发环境），再安装PyDev。
4，需要安装id-utils，这部分实际上没有仔细的运行。
5, 请执行install_dev.sh

参考
----

1, Python GI API Reference:
    http://lazka.github.io/pgi-docs/
2, 本机代码参考：
    /usr/lib/python2.7/dist-packages/gi

3, gtk source view的语言分析
/usr/share/gtksourceview-2.0/language-specs

4，修改global的配置文件，加入需要避免的路径。
cp ./doc/global/examples/gtags.conf etc/
在common::skip中加入obj/

计划
----

开始进入结构调整期，在增加新的功能时，发现开发非常的不方便，应该将函数和组件的调用方法不断的剥离成
1，有一个主体结构，但是此结构下没有具体的功能。
1.1 主体结构以注册和消息分发机制为核心。
1.2 画面不是组合的，而是基于请求的，请求什么样的画面服务，就显示什么样的画面。
2，在此主体结构上，添加功能组件，称为组件。功能组件之间保持彼此之间的独立性。
2.1 组件之间不可见，而是通过发送消息的方式来处理。
2.2 组件可以分为画面、处理、数据和控制等类型，但是都是组件。
2.3 需要建立组件之间的依赖关系，需要保证组件之间的加载顺序。 依赖关系在安装和启动方面还是比较重要的。
3，实现：容易添加新的组件、修改组件内部的实现而不影响其他组件。
4，为以后扩展新的代码分析和界面处理而做准备。

设计的基础原理
---------------

设计不是凭空产生的，不是看了基本设计书后想实践而出的，也不是大家一起编写后就会自然生成的，
而是根据具体的需求，结合底层的技术实现方法，而且采取的最优化实现方式。
所以设计的第一步就是确定需求。

需求的原则
-----------

需求不是开发人员拍脑袋得到的，它来源于使用者的渴望。也许使用者一开始也无法说清楚，
可以通过原型、模拟、类比、参考来将这种说不清楚的东西搞明白。

另外需求是变化的，不是一成不变的，尤其是面对不同的用户时，甚至不同用户在不同的时期也有不同的需求，
设计人员需要将来自不同用户、不同时期的需求做一个整理，
分成不同的方面、时期和来源，然后按照重要性划分成不同的阶段，然后在每个阶段尽量将可以作为一个整体的需求放在一起，这样实现起来方便、规整。
最后根据上面的需求，然后选择设计架构。

AE的需求
---------

第一个阶段的AE已经实现了，当时没有特意的收集需求，毕竟使用者就是我自己，
想到什么就实现什么，所以主要的功能就是可以做成一个项目，然后包含若干代码，能够对代码进行分析和编辑。

实现了第一个阶段后，就遇到两个突出的问题，
第一个问题是程序挺复杂，代码也集中在三四个文件中，使用中出现了许多问题，虽然逐步解决了，
  但是感觉问题挺难分析，尤其是在停止开发一段实现后，再去看、调试代码时，常常不知道从哪里下手。
第二个问题是添加新功能时工作量大，比如添加一个检索的功能，发现在menu部分的几个函数中需要不断的代码，
  然后添加传递到window的函数，再在window中添加若干真正的功能，还有可能和其他的功能冲突。
两个问题实际上是一个问题，就是程序复杂了，无法像刚开始一样快速开发，而且随着开发推进，复杂没有收口反而不断的增大，
如果不修改的话，推测之后将进入无法维护的现实状况。

基于上面两个问题，提出了第二个阶段的主要需求：
1，对开发要提速，主要集中在画面、代码分析工具等二次开发上。
2，对调试和测试提出要求。
3，利用上面两个功能，快速的开发一些代码分析和第三方方便工具的模块。

框架怎么设计？
---------------

设计方案应该有效的降低系统的复杂程度，
其中一项就是代码的长度，越复杂，代码应该越多。
还有一项是修改代码或添加新功能的成本，越复杂，成本越高。

AE的框架设计
-------------

此框架的基础设计是基于“组件”结构，框架负责三件事情：
1，组件仓库(component repository)，负责启动的组件的实例管理，可以设计成池，需要实现生命周期。
2，组件加载器(component loader)，负责启动组件，对于灵活系统，组件可能需要从不同的来源获取，或者需要动态获知，所以加载器就不是简单的部分。
3，组件管理器(component manager)，建立在仓库和加载器基础上，是它们和由组件组成的程序之间的桥梁。
另外，还有一个组件系统，它是以组件为基本的组件形成的系统，此系统可以是完全由组件组成的，也可以重要和主要的功能由组件完成。

整个系统的运行原理是：比如组件系统发送一条请求，要新的组件，那么这条指令需要传递给组件管理器，管理器到组件仓库中查找，
如果已经创建且可以复用，那么就将组件返回，如果不可以，就通知组件加载器加载一个新的组件，注册到仓库后，
返回给组件系统的请求者。

组件在此基础上聚焦自己的功能，可以方便的编写和扩展组件。
此程序需要实现组件的注册、生命周期和运行环境(比如通信)。

为了实现组件的强约束，需要在组件的协同上，实现标准通信协议、标准组件，以及协作规范等等。

* 组件的作用是把功能拆分成多个模块，这样在复杂的、大规模代码的基础上可以容易的修改和增长，当然也容易删减功能。
* 服务注册机制是把原来功能是函数提供的，变成了基于“注册服务”来提供的，基于“注册服务”的调用方式好在
  必须提供运行时可以查的接口，以及明确的帮助和参数传递，这些都是可以动态组合的。当然，缺点是调用效率不高，
  这对于桌面应用来说已经够了。
* 通信管道作用是把基于组件或基于模块，反正基于层次结构的通信方式，变成了扁平的结构。
  解释一下，基于控件的方案中，想调用一个控件，必须找到上层的窗口、然后顺着窗口的包含策略一层一层的找下去，
  直到找到控件，然后再调用接口。如何复杂而且不高效的寻找机制下，通常的解决方案是将所有的控件（可能一开始只有少数，
  到了后期就基本上所有重要控件）都放到上层某个对象中引用，这样查找方便。不过对于跨窗口的功能和数据来说，
  这样就比较复杂了。还有一种方案是每个控件提供的功能都在上层实现接口可以调用，然后上层的上层又可以调用上层的接口，
  这个方案只在小的组合控件之类的实现过，对于大型应用程序来说实现成本过高，所以很难有程序这样去实现。
  
  那么“通信管道”这个方案，就是所有的模块如果需要通信的话，都注册到上面，可是实现“调用”和“回调”机制，
  还可以屏蔽服务提供方的类型和实现细节，是一个优美的设计。
  不过缺点是对于大型的应用来说，注册的组件会很多，如果不分组或者分层，那么查找的成本会变高。
  
  分组：在组件的注册和调用上，加入多级分组策略，"A.B.C"表示A组中的B组的C成员。因为分组，所以查找成本就会急剧下降。
  分层：每层都有自己的通信管道，然后允许和本层或者下层管道通信。
  分组和分层本质上并无不同，虽然实现的技术方法不一样。

组件的设计
-----------

组件的核心是：
	强替换性对象，普通对象技术虽然强调独立、内聚，但是指示思想，无法强力约束。
	然后以组件为基本单元组成“组件系统”。

促进组件化的设计，效果是每个功能有自己的组件，然后可以挂接在一起配合使用，在编写每个组件时，不用总是考虑其他组件的问题。
设计方案如下：
1，主体建立基本的注册、通信和协作机制，真正的功能组件都挂接在上面。
2，每个组件无论是按照什么方案划分的，都提供独立、完整、可以配合的功能。
   每个组件都是内聚的设定，它只要符合每个要求，都能完成自己的功能。

因为组件初始化有先后顺序，且有些组件是被其他组件生成的，所以这里需要考虑初始化的顺序问题。
比如有些组件向menu注册自己的菜单，那么就需要假定菜单在这些组件之前就被建立了，但是实际上，存在在menu之前创建的组件。
也就是说，存在组件可能需要在另外一个组件初始化后再初始化自己的情况。
解决方案有多种：
1，所有的组件都必须一起建立，对于无法事先建立的（比如view相关的），可以建立“代理组件”，此组件保存所有的请求，等到真正的对象建立的时候，
  再根据之前传递的信息建立这个对象。之后的请求就直接传递给此对象。
  缺点：无法实现动态组件，毕竟有些组件是运行时才决定的，或者加载的，无法在之前都建立起来。
  优点：框架实现简单。
2，建立严格的初始化先后顺序，如果发现服务不存在，立刻就出现错误。如果组件依赖于另外的组件，那么就需要在此之后初始化。
  缺点：无法实现真正的动态加载，另外严格的初始化顺序不一定实现，比如 menu 需要 dialog，dialog 也需要 menu，那么谁先谁后初始化？
3，组件在注册后，需要发送“服务已被注册”广播事件，比如menu通知“view.menu.add”服务上线了，需要注册自己菜单的，接到这个通知后，就注册。
  组件自己启动时，先查找是否存在“view.menu.add”服务，如果有再注册。
  优点：允许动态加载，无论先后顺序。
  缺点：组件的实现方式就比价复杂，需要允许重复发起请求。
4，从代理组件延伸，建立一套标准的接口，然后建立这些接口的组件实现，这些接口做为组件服务的中间层，屏蔽实现的细节。
  优点：可以规范实现。
  缺点：不利于扩展，再好的设计，也无法囊括未来所有的可能。

	如果是双盲组件，按照现实生活中的方法，应该是在具有“共同认识”的前提下，阅读对方组件的说明，
	然后分析如何使用，接着尝试调用是否正确。
	最后评测各种方案，得到最优的结果。
	
	所以建立中间、标准通信协议或组件是正确的实现方案，但是这种方案无法解决动态加载问题，只是解决了组件的通信标准问题。
	动态加载有一个“简单的实现”，
5，当后期每次加入一个组件后，就调用其他组件的“初始化”方法。组件的初始化方法必须是可以重入的。 <-- 目前是按照这样做的。
6，建立组件之间的依赖关系，然后按照顺序启动。 
  缺点：无法运行时，动态添加组件。
7，广播机制，但是一个服务注册的时候，就向所有的组件广播说“此服务实现了”，然后需要此服务的组件马上发出服务请求。
  缺点：组件的实现就会复杂，而且组件比较多时，加入一个组件的时间会很长。

组件是建立整个系统的基石，但是并不意味着所有的问题都要组件来解决，
许多问题是建立在组件基础上，再复杂化的设计，比如中间协议、层次划分等。

问题
----

1，在目前的架构中存在数据结构和画面、处理的区别，那么模型和算法在目前的框架中如何设计？
  面向对象的设计中，不区分数据结构和算法等，而是按照独立的功能划分不同的对象，每个对象都是包含数据和动能的一个独立个体，
  组件的设计方案也是如此，不能将整个系统划分为数据和画面，而是应该在底层按照独立性原则形成不同的组件，也就是更高级的对象，
  然后再组合成更更加高级的组件，对应不同层次的需求！
  结合AE这个项目，先划分层次，然后根据每个层次制定不同的组件划分，然后实现这些组件。
  在实践中，基于GUI控件、数据结构等已有的结构，组件将做出妥协。GUI控件必须相互之间包含，而且有些刷新、数据持有等动作都已经安排好了，
  那么控件想做成组件，实际上只需要把那些没有被GUI实现的功能做成组件对外提供的服务。
  
2，如何把功能都拆分出去？依据是什么？怎么作比较合理？
  按照基于对象的原理，应该将一个独立的功能做成一个对象，对象内部可以包含数据结构和对外的接口，屏蔽内部的实现机制和流程。
  如果对象内部的数据结构的细节需要暴露出去，那么这个设计就不够独立，如果内部的功能细节还需要外部了解才能使用，那么这个设计也是不够独立。
  应该在包裹的功能和数据基础上再建立更加高级的层次结构才是建立了独立的对象，也就是现在结构设计中的“组件”。
  
  反思一下菜单的设计，我想把菜单本身如何显示菜单、快捷方式等变成一个简单的接口：添加菜单，但是在实际的编写中发现，
  一个模块如果想添加菜单，不仅仅是调用一个“add”接口的问题，比如诸多菜单应该如何分组？点击了菜单后如何处理？
  我的思考是，菜单项目是有分组的，所以必须加入强的“规范”，作为菜单组件的一部分。
  至于点击菜单后的处理，不应该是菜单组件的一部分，菜单组件只能按照其他菜单请求显示的设定而发出被点击的信号，
  至于谁处理，应该是外部模块的机制，而不是菜单组件处理的。 那么谁处理？实际上，都是主窗口在处理，
  所以实际上应该是主窗口申请这个服务，然后自己根据菜单激活结果，注册具体如何实现！
  
3, 在 workshop中添加一个option，发现比较麻烦，要在workshop中添加数据项目，要修改设定文件的读写，
  然后修改 workshop preferences对话框，需要设定和显示同步，还要修改画面后修改设定。
  最后修改设定后，还需要找到方法修改所有已经打开的编辑器，那么之后打开编辑器也需要知道这个选项。
  在整个上面的流程中，其实可以用“链接”的方式，将画面显示控件、数据对象的字段以及文件的保存字段都对应起来，这样就省了很多的工作。
  这个就是“用关系维持对象一致”的设计方案。
  
4, 初始化整个体系崩塌，前提：
    a，目前无法将所有的组件都一起构造出来，需要虽然运行生成出来，比如有些组件内部又生成一些组件。(组合组件)
    b，无法预料到组件生成的先后，比如有些模块需要调用一些服务，但是这些服务所在的组件可能还没有生成，怎么办？（动态加载）
    c，某些组件可能在运行时被卸载，换成其他的组件。（动态替换）
  所以，可以如下设计：
    a，想要可以动态的启动、卸载、替换组件，必须松耦合，目前基于消息的请求服务模式是适合的。
    b，想要动态的启动，以及组合组件，那么请求服务就可能会出现先后问题，既然所有的功能是基于服务的，
      就应该基于服务来解决。如果加入新的服务，就发送“注册服务”信息，如果删除新的服务，也发送“注销服务”信息。
    c，因为服务是基于组件必须可以使用后的，所以服务注册应该在组件建立完整实例后进行。
      组件在注册自己服务后，发送自己的请求，无论此服务是否存在。然后监听“注册服务”事件，如果发现此服务有人注册，
      那么立刻请求自己的服务。  <-- 这个实现有点复杂，且比较困难实现的没有问题。是否暗示应该从命令方式转为描述方式。
    d，想减少复杂性的话，最好在开始就创建一些默认的组件，但是这样就违反了“组件替换”的需求。
    --> 目前没有好的方案，就是在在run之前建立FwManage的实例，然后在run之前调用register，之后都调用了load，
        如何从根本上解决这个问题，需要再思考！

5, 消息机制除了注册对外提供的服务后，还需要提供消息和监听机制。
  比如有些控件，它在某些动作下会引起事件，但是此事件并不应该由它处理，所以它发出事件后，
  其他的组件应该监听此事件，然后做出处理。
  
  组件提供的服务，是不知道什么时候应该调用，但是知道应该做些什么，
  而提供的时间，则是知道什么时候发生了什么，但是不知道应该做些什么。 用FwEventPipe来实现。

总结
----

1，将ViewBookmarks涉及的功能拿到外部，核心的主体是将bookmark的功能从ViewWindow中拿出，
  因为bookmark涉及到Window的一些内部的功能，比如make_book，这个需要了解内部编辑器的细节，
  所以我在这里做了分层，将涉及到window和编辑器的功能还保留在window中，然后将“动作”和“主要处理流程”
  都迁移到 ViewBookmarks 中。