环境要求：
1，需要安装Python 2.6，用于Python语言。
2，需要安装PyGObject，用于使用Gnome控件（适用于Gnome 3.0）。
3，eclipse 4.4（Java开发环境），再安装PyDev。
4，需要安装id-utils，这部分实际上没有仔细的运行。
5, 请执行install_dev.sh

参考：
1, Python GI API Reference:
    http://lazka.github.io/pgi-docs/
2, 本机代码参考：
    /usr/lib/python2.7/dist-packages/gi

3, gtk source view的语言分析
/usr/share/gtksourceview-2.0/language-specs

4，修改global的配置文件，加入需要避免的路径。
cp ./doc/global/examples/gtags.conf etc/
在common::skip中加入obj/

Plat:
2017/9/9 ～ ？
开始进入结构调整期，在增加新的功能时，发现开发非常的不方便，应该将函数和组件的调用方法不断的剥离成
1，有一个主体结构，但是此结构下没有具体的功能。
1.1 主体结构以注册和消息分发机制为核心。
1.2 画面不是组合的，而是基于请求的，请求什么样的画面服务，就显示什么样的画面。
2，在此主体结构上，添加功能组件，称为组件。功能组件之间保持彼此之间的独立性。
2.1 组件之间不可见，而是通过发送消息的方式来处理。
2.2 组件可以分为画面、处理、数据和控制。
2.3 需要建立组件之间的依赖关系，需要保证组件之间的加载顺序。
3，实现：容易添加新的组件、修改组件内部的实现而不影响其他组件。
4，为以后扩展新的代码分析和界面处理而做准备。

框架怎么设计？
-----------
比如现在有 data是File/Project/ProjectList，
然后画面有Tree/List/InfomationDialog 等。
最后，控制有 new（创建信息的模型或者画面）、delete（销毁信息模型或画面）、change（修改信息模型或者画面）、link（将两个对象相互关联，一个改变后，另外一个也跟着改变）。

促进组件化的设计，效果是每个功能有自己的组件，然后可以挂接在一起配合使用，在编写每个组件时，不用总是考虑其他组件的问题。
设计方案如下：
1，主体建立基本的注册、通信和协作机制，真正的功能组件都挂接在上面。
2，每个组件无论是按照什么方案划分的，都提供独立、完整、可以配合的功能。

设计方案应该有效的降低系统的复杂程度，
其中一项就是代码的长度，越复杂，代码应该越多。
还有一项是修改代码或添加新功能的成本，越复杂，成本越高。

因为组件初始化有先后顺序，且有些组件是被其他组件生成的，所以这里需要考虑初始化的顺序问题。
比如有些组件向menu注册自己的菜单，那么就需要假定菜单在这些组件之前就被建立了，但是实际上，存在在menu之前创建的组件。
也就是说，存在组件可能需要在另外一个组件初始化后再初始化自己的情况。
解决方案有多种：
1，所有的组件都必须一起建立，对于无法事先建立的（比如view相关的），可以建立“代理组件”，此组件保存所有的请求，等到真正的对象建立的时候，
  再根据之前传递的信息建立这个对象。之后的请求就直接传递给此对象。
  缺点：无法实现动态组件，毕竟有些组件是运行时才决定的，或者加载的，无法在之前都建立起来。
  优点：框架实现简单。
2，建立严格的初始化先后顺序，如果发现服务不存在，立刻就出现错误。如果组件依赖于另外的组件，那么就需要在此之后初始化。
  缺点：无法实现真正的动态加载，另外严格的初始化顺序不一定实现，比如 menu 需要 dialog，dialog 也需要 menu，那么谁先谁后初始化？
3，组件在注册后，需要发送“服务已被注册”广播事件，比如menu通知“view.menu.add”服务上线了，需要注册自己菜单的，接到这个通知后，就注册。
  组件自己启动时，先查找是否存在“view.menu.add”服务，如果有再注册。
  优点：允许动态加载，无论先后顺序。
  缺点：组件的实现方式就比价复杂，需要允许重复发起请求。
4，从代理组件延伸，建立一套标准的接口，然后建立这些接口的组件实现，这些接口做为组件服务的中间层，屏蔽实现的细节。
  优点：可以规范实现。
  缺点：不利于扩展，再好的设计，也无法囊括未来所有的可能。

如果是双盲组件，按照现实生活中的方法，应该是在具有“共同认识”的前提下，阅读对方组件的说明，
然后分析如何使用，接着尝试调用是否正确。
最后评测各种方案，得到最优的结果。

所以建立中间、标准通信协议或组件是正确的实现方案，但是这种方案无法解决动态加载问题，只是解决了组件的通信标准问题。
动态加载有一个“简单的实现”，
5，当后期每次加入一个组件后，就调用其他组件的“初始化”方法。组件的初始化方法必须是可以重入的。