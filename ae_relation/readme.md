# Agile Relation Editor

不要人为复杂化！
最好的设计是 底层以原子功能为主，顶层一个UI接口为主，中层是粘合结构。

## 安装：

1. sudo pip install prompt_toolkit 需要升级到 2.0.9 以上。
1. sudo pip install CodernityDB
    这个是 Python 语言开发的，嵌入到程序中的NoSQL DB，是 key-value 类型。

## 有三个阶段：

1. 元素关系描述数据关系，可以对这个数据关系进行管理(insert/delete/change/select)。
2. 元素关系是蓝图（blueprint），相当于结构描述，程序根据蓝图可以组成应用。
    组装后的程序自行运行，运行的内部调用还是Python之间的调用。
    当改变蓝图，就同时改变应用的结构。
3. 元素关系就是一切，每个特殊的元素都是特定的模块，关系来设定这些模块的组成方式和通信方法。
    模块之间的通信都通过关系来传递（就像fidl）。这样元素关系就是应用，应用就是元素关系。
下面开始第一阶段的设计和实现。

## 目标：

用特定的语法描述元素和它们之间的关系，然后可以显示、查询和编辑。
需要符合我个人对于这个世界的各种理解方法：
  1. 所有的事务都称为对象。
    对象具有类别（类别也是对象），同样类别的对象具有同样的行为逻辑和特征值，当然具体对象具有具体的特征值。
    此软件可以根据类别建立具体对象，并且如规定的一样具有同样的行为逻辑和基本的特征值。
  2. 对象之间用特殊对象（称为：关系）相连。
    此软件可以建立对象和特殊关系，并进行设定。比如“继承”、“拥有”，这些都是特殊的关系，而不超出对象和关系的范围。
  3. 建立了关系的对象全体，可以称为模型。
    此软件可以建立模型，并进行显示、查询和修改。
    并且可以根据模型运行。<----------- 这个非常的重要。
  4. 对象之间可以不断的转换，是动态的。然后根据公式或者分析方法，演变成静态的关系公式。
    此软件可分析模型，并根据设定好的分析工具，分析关系和对象，变化成新的模型。
  
## 具体需求：

0. 不用重复发明车轮，如果已经有好的实现就用，没有必要为了炫耀自己的技巧去实现一些东西。
1. 可以录入数据，能够符合大多数数据的要求。比如带有属性的对象，然后描述对象和对象之间的关系。
2. 可以以人的思维视角，去查询、改变数据。
    比如可视化操作，或者更加容易的操作。
        比如上一次的脚本存下来，对于结果和初始条件可以很容易的修改，边修改边看到答案。
    人容易理解的查询语句，而不是SQL、Python脚本之类基于底层实现的。
        就是按照人对一个事情的理解，可能会存在模糊和矛盾的地方，可以进行提示。
    可以通过描述要什么，而由程序自己选择算法来实现。
        比如我想去A，那么到A的途径就由程序来设计。这个不是安排好的算法，而是用AI进行启发的解决。
3. 可以将某个数据“依附”到其他的数据上，通过依附建立数据之间的关系。
4. 用户建立了基本的模型(model)后，可以针对模型进行各种分析和处理。
    1. 最简单的分析就是检索模型中的某些类型的数据或者特定的元素。
        然后再根据检索的结果，显示某个方面，比如显示为关系图，或者类图等等。
    2. 处理就复杂多了，可以添加更加复杂的数据，也可以减少和修改。
5. 数据可以有不同的来源，可以是
    1. 特定的python脚本文件，直接调用内部的model、control的接口。
    2. 是内部的script脚本，通过parse、control解析后，调用model的函数。
    3. 可以是数据文件，被反序列化后，直接形成model数据。
    4. 来自命令行的要求，这里允许简单的数据输入，然后就可以形成简单的模型，方便马上验证想法和测试。
    总结一下来源： command line, inner script(各种), serialized data, invoke inner API.
    所以就要求，程序允许接受各种输入，这个不是故意复杂化，而是因为测试和实际开发的需要。
    另外，这里说的是数据的来源，并不包括所有的外部输入，比如操控多个模型的命令。
6. 对于程序的控制：
    0. 模型的数据最好是模型自己控制输入，而不再需要其他模块负责，因为数据本身已经很复杂了，再复制接口是没有必要必要的。 
    1. 对于模型的各种遍历和无改处理。
    2. 对于多个模型的处理，比如合并、转化等。
    3. 对于程序的处理，必须启动、关闭、交互等。

目前想用到的应用场景是：数据分析（彩票分析）、程序关系（调用关系、静态关系等）、逻辑分析关系等。
  
## 设计方案：

1. 元素(element)是此程序中所有的对象的统称。
    1. 元素必须具有唯一的内部ID，这样方便确认。这样有利于内部程序明确区别和保存。
1. 关系(relation)是元素之间的关系，实例必须关联两个以上对象。需要强调的是，关系也是元素。
    建立关系时，关系涉及到的元素和关系本身都需要验证是否符合要求，否则关系无法确立。
    1. 属性(property)是一种特殊关系。
        指依附于某个元素的元素，当属性依附的元素消失时，则属性消失。这个是简化“两个元素以属性关系相关”的说法。
    1. 包含(contain)是说：容器持有其他元素的引用，可以检索、移入移出被包含的元素。
        被包含的元素没有必要是同一个类型的。
    1. 类型（type）是两个元素之间的关系。
        一个元素1是另外一个元素2的类型，那么就是说元素2满足元素1的所有要求。
        在目前编程语言中，class是典型的类型，一般是元素1规定了需要实现的field和method，而元素2必须按照实现。
        1. 为了方便使用。针对添加类型，元素可以按照类型衍生出来。
            类型和元素之间的关系是“衍生”，正向和反向的称呼不同。
            类到元素是衍生，元素到类是继承。

## 具体的实现：

0. input是输入，可以是view、console、Text等。output是输出，可以是view。
1. Model：
    1. 包含一个完整的元素和关系，提供 register event/callback method 接口，
        以及遍历和分析接口。 
    2. Element是基本的数据结构，包含Relation。
    3. Element和Relation的设计和实现
        Relation和Element之间功能的切分一定要清晰，因为目前没有多少实现的经验，所以还不知道怎么设计。
    4. Model需要提供给外部一直的接口，【这里有疑问，如果model数据的输入格式和来源不同，那么Model怎么处理？】
2. mvc层，包含Control + Model + View，功能主要是：
    1. Control，是对MV的控制，但是只能控制配对Model。
        可以接受外部的命令包，然后针对MVC层进行处理，不负责具体的Model的处理，
        可以将外部的数据处理传入到Model来处理。
        Control 就是 Executor ！
    2. View 是模型数据的表现，可以是显示的界面，日志输出，或者是文件。
        View可以是多个，这个都由Pipe来决定。
        View将输入的信息也变成标准命令，然后交给Executor来执行。
3. Executor，负责将标准的model命令，变成对于Model的调用。
    当Model支持的函数不同时，Executor负责转接。
    当Model的标准命令的版本不同时，Executor负责转接。
4. Parser，负责将各种输入，转化为标准的model命令。Parser可以是各种来源（GUI、Console、Script）或者
    各种命令格式（简单的命令、复杂脚本语言等）。
    1. Parser：负责将传入的输入导入到
        负责分析传入的命令，变成命令包(command package)，自己执行，或者发送给更下层的Control。
5. Pipe层，功能主要是
    1. Processor: 容纳一个MVC实例，这样就允许App同时有不同的 Model。【目前不允许MVC之间交互】
6. App层，建立基本的程序运行结构，包括建立 input/parser/executor/model/view 模式。
    【这样设计的方案是，主要是建立命令执行和交互执行两种模式Mode】
    1. 解释命令行，然后创建 Parser + Container 模型，这样就建立基本的运行机制。
    2. 将“交互界面”的输入和Parser连接在一起。
7. 如果有多个Parser需要协同怎么办？简单的实现就是Parser1对于委托分析的就调用Parser2。
   如果有多个Executor怎么办？一个是Pipe可以有多个Executor，命令必须是区分的。另外一个是多个Pipe，每个pipe一对parser和executor，但是input是一个。

为了让命令更加有通用性：
command text --------> command standard package ----------------> model
              parser                                executor

所以需要“输入、分析、执行模型”（IPE）:【只是最基本的处理流程】
input --> parser --------> Executor ---> Model ---> output
各种输入   分析输入得到命令     处理命令       改变模型     输出（view或者序列化）

Executor/Model/Output = Control/Model/View：
Control(=Executor) ---> Model --> Output(View/Storage)

那么需要 Subject-Observer模式，建立Model和View之间的关系。

这里需要Control能够将 Parser/Executor 和 Model 连接起来：
Parser --> Executor --> Model

基本的程序结构
        App/Container --> MVC ----------> Parser/Executor/Model  -----> Output
input >>----程序相关--------控制Model----------模型相关 -------------------输出相关的
[这样在Executor处，就可以建立command history，这样可以回滚、重播和找错]

所有数据转化流程：
                                        [parser]       [executor]
cmd line/interview cmd  ----> model script --> command package --> model method ----> model <----> serialized data/View
                         \--> control app/mvc
                           [parser]

核心的是两条：
1. 根据 “输入、分析、执行、模型、输出” 为一条核心执行设计线索。
2. 根据 ”控制(输入、分析、执行） -> 模型 -> View“ 的模式，是核心的架构。
    两个设计架构是结合在一起的。 执行就是控制，输出就是View。


## 要点：

1. 设计成以上结构，是方便替换实现方法，但是会需要程序设计的非常精巧，这个尽量采用简单的实现方案吧。
1. 显示、存储需要和数据模型尽量分离开，因为这个程序的核心是“数据”，如何显示和怎么保存都会灵活变化。
1. 起点高一些吧，建立“领域语言”，并且可以进行编程。
   领域语言不一定是独立的解释、编译语言，可以是建立在某种特殊方法（比如早期建立在C的宏基础上的objective-c语言），
   或者就是一个复杂的类库，这样就不需要建立额外的语法了。
   
## 对外接口：

描述命令接口
rlt --execute <script file>
rlt --interview

进入交互模式后，可以执行命令
命令可以是下面几类：
0. execute <script file>，脚本文件中可以包含下面所有的种类。
1. app 管理应用程序 （$xxx）
2. processor 管理内部的处理 (!xxx)
3. model 针对MVC中的M，当然需要通过parser解析 (xxx)


## 进度(要尽快！！！不要磨蹭，抓住空闲时间！)：

1. -建立基本的运行结构，只要能够运行起来。-
2. -命令解析，放在后面做。仿效git的命令方式。-
3. 目前的重点是数据的结构。
  -1. 测试驱动：先写好需要执行的脚本，和产生的效果，然后再实现真正的逻辑。-
4. 如果想建立统一的关系后，用任意UML图显示，那么就先要建立统一的UML关系。
  -1. package/component/module/class/field or method-
  -1. 要不要考虑二级模型转化机制，就是一个通用的关系系统，然后将此关系系统转换成UML描述的关系，最后转换为显示的图。
   不过这个比较麻烦。目前编程语言是通过"对象继承"来实现复杂类型关系的，而转换则需要太多的层次结构，实现比较麻烦。
   另外一种方案是建立通用关系的定义，然后在此基础上建立更加具体和UML定义，用这个具体定义去描述系统，
   最后再生成UML。【目前是按照第二个方案进行的】-
  -1. 活动图和序列图都应该描述“函数”和“函数”之间的关系。-
  -1. 实现新的Input，只需要简单的控制台，不需要 prompt_toolkit。-但是家里的控制台无法使用这些，不知道为什么？
  -1. 建立简单对象之间的关系。（不是UML）-
  -1. 模块越来愈多，如何组合，谁和谁组合，以及他们之间的一致接口很重要。
   组合方式用“脚本”来描述如何？而不是通过复杂的命令行参数，这个会导致复杂程序命令说明。
   目前Model和Parser、Executor、Output是捆绑在一起的，如果无法从一致的语法进行扩展，那么只能是一套系统就是一套。
   这样的话，可以用 processor的名字代替整个一套的名字。-
  -1. ae_rlt -m basic -i 的 !xxx 命令不认识。-
  -1. 显示正确的帮助。-
  1. 基础模型或者是其他模型，对于同一类的对象，缺少特殊的标签。或者说生成的图像无法突出的表现出重点的元素。
  1. 模型中有许多包含关系，如果只是用线表示，很不清晰。
  1. script中不支持换行！
  1. process可以通过注册，或者config配置来组合，或者其他。
  1. interactive模式下，script无效。
  1. 去掉目前可以解决的TODO。
  1. 允许使用简单的语句就可以实现 关系的描述，包括UML的。现在的语法太复杂和难以描写。
  1. 高级的模型可以用简单的模型通过扩展来实现，这个扩展开始可以是一个python的类，之后可能是通过脚本来扩展。
  1. 通过数据文件，加载model。

## 琐碎记录：

如果建立比较通用的关系后，想建立更加具体或者复杂的关系，比如UML，那么应该建立某种更高级的规则，来描述 关系A=关系B+关系C之类的。
比如A是B的父类，B是C的父类，那么A也是C的父类。诸如此类。

1. 最基本的是“拥有”关系，比如"B--have-->foo"，就是“B拥有foo”。如果关系没有写就是缺省。
  关系有方向性，有前后关系。
2. 其他关系： A--调用-->B，是“A 调用 B”。
3. 组合关系： “A调用了B的foo函数” = ”B拥有foo函数，而A调用了foo“，如果再深究的话，那么A是无法直接调用函数的，所以”A拥有的bar和B拥有的foo函数之间是调用关系“。
  组合关系是说，将一些关系的组合，变成一个关系的统称。反过来，可以根据一个关系的统称，转化为一组关系。这个符合现代语言的定义。

就是说，以目前的情况看，不断扩展python的类比较困难，也不是长久之策，最好是允许在脚本中扩展类型。但是

1. 扩展类型可以，但是扩展类型具有的特定实现就很难。因为目前显示类图的工具不是简单的在graphiv上组合得到的。
2. 类型扩展目前受制于 UML 本身。
3. 最好是允许扩展“类型”，然后还可以针对特定的类型，指定的特定的实现。

pipe的结构挺好，但是怎么实现？
1. pipe可能是临时的，比如在运行交互输入时，中间想执行一个脚本。那么这就同时有两个pipe，因为输入不同，所以Model和Executor一样。
    那么Executor是否可以同时运行在两个pipe中？
    回答：pipe必须能够允许其中的模块可以被其他的pipe同时顺次使用。
        可以临时的创建一个Pipe，然后进行处理。完成后就销毁。
2. pipe的概念是否太重？在普通的程序设计中，各个模块直接调用是否就行了？
    回答：不是，因为在app中存在调用这些模块的大量代码，这就是pipe应该存在的例证。

