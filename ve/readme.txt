环境要求
-------

1，需要安装Python 2.6，用于Python语言。
2，需要安装PyGObject，用于使用Gnome控件（适用于Gnome 3.0）。
3，eclipse 4.4（Java开发环境），再安装PyDev。
4，需要安装id-utils，这部分实际上没有仔细的运行。
5, 请执行install_dev.sh

参考
----

1, Python GI API Reference:
    http://lazka.github.io/pgi-docs/
2, 本机代码参考：
    /usr/lib/python2.7/dist-packages/gi

3, gtk source view的语言分析
/usr/share/gtksourceview-2.0/language-specs

4，修改global的配置文件，加入需要避免的路径。
cp ./doc/global/examples/gtags.conf etc/
在common::skip中加入obj/

计划
----

开始进入结构调整期，在增加新的功能时，发现开发非常的不方便，应该将函数和组件的调用方法不断的剥离成
1，有一个主体结构，但是此结构下没有具体的功能。
1.1 主体结构以注册和消息分发机制为核心。
1.2 画面不是组合的，而是基于请求的，请求什么样的画面服务，就显示什么样的画面。
2，在此主体结构上，添加功能组件，称为组件。功能组件之间保持彼此之间的独立性。
2.1 组件之间不可见，而是通过发送消息的方式来处理。
2.2 组件可以分为画面、处理、数据和控制等类型，但是都是组件。
2.3 需要建立组件之间的依赖关系，需要保证组件之间的加载顺序。 依赖关系在安装和启动方面还是比较重要的。
3，实现：容易添加新的组件、修改组件内部的实现而不影响其他组件。
4，为以后扩展新的代码分析和界面处理而做准备。

框架怎么设计？
-----------

设计方案应该有效的降低系统的复杂程度，
其中一项就是代码的长度，越复杂，代码应该越多。
还有一项是修改代码或添加新功能的成本，越复杂，成本越高。

框架的基础设计是基于“组件”结构，框架负责组件的注册、生命周期和运行环境(比如通信)。
组件在此基础上聚焦自己的功能，可以方便的编写和扩展。

在组件的设计基础上，再加入组件的协同上，比如标准通信协议、标准组件，以及协作规范等等。

* 组件的作用是把功能拆分成多个模块，这样在复杂的、大规模代码的基础上可以容易的修改和增长，当然也容易删减功能。
* 服务注册机制是把原来功能是函数提供的，变成了基于“注册服务”来提供的，基于“注册服务”的调用方式好在
  必须提供运行时可以查的接口，以及明确的帮助和参数传递，这些都是可以动态组合的。当然，缺点是调用效率不高，
  这对于桌面应用来说已经够了。
* 通信管道作用是把基于组件或基于模块，反正基于层次结构的通信方式，变成了扁平的结构。
  解释一下，基于控件的方案中，想调用一个控件，必须找到上层的窗口、然后顺着窗口的包含策略一层一层的找下去，
  直到找到控件，然后再调用接口。如何复杂而且不高效的寻找机制下，通常的解决方案是将所有的控件（可能一开始只有少数，
  到了后期就基本上所有重要控件）都放到上层某个对象中引用，这样查找方便。不过对于跨窗口的功能和数据来说，
  这样就比较复杂了。还有一种方案是每个控件提供的功能都在上层实现接口可以调用，然后上层的上层又可以调用上层的接口，
  这个方案只在小的组合控件之类的实现过，对于大型应用程序来说实现成本过高，所以很难有程序这样去实现。
  
  那么“通信管道”这个方案，就是所有的模块如果需要通信的话，都注册到上面，可是实现“调用”和“回调”机制，
  还可以屏蔽服务提供方的类型和实现细节，是一个优美的设计。
  不过缺点是对于大型的应用来说，注册的组件会很多，如果不分组或者分层，那么查找的成本会变高。
  
  分组：在组件的注册和调用上，加入多级分组策略，"A.B.C"表示A组中的B组的C成员。因为分组，所以查找成本就会急剧下降。
  分层：每层都有自己的通信管道，然后允许和本层或者下层管道通信。
  分组和分层本质上并无不同，虽然实现的技术方法不一样。

组件的设计
--------

促进组件化的设计，效果是每个功能有自己的组件，然后可以挂接在一起配合使用，在编写每个组件时，不用总是考虑其他组件的问题。
设计方案如下：
1，主体建立基本的注册、通信和协作机制，真正的功能组件都挂接在上面。
2，每个组件无论是按照什么方案划分的，都提供独立、完整、可以配合的功能。
   每个组件都是内聚的设定，它只要符合每个要求，都能完成自己的功能。

因为组件初始化有先后顺序，且有些组件是被其他组件生成的，所以这里需要考虑初始化的顺序问题。
比如有些组件向menu注册自己的菜单，那么就需要假定菜单在这些组件之前就被建立了，但是实际上，存在在menu之前创建的组件。
也就是说，存在组件可能需要在另外一个组件初始化后再初始化自己的情况。
解决方案有多种：
1，所有的组件都必须一起建立，对于无法事先建立的（比如view相关的），可以建立“代理组件”，此组件保存所有的请求，等到真正的对象建立的时候，
  再根据之前传递的信息建立这个对象。之后的请求就直接传递给此对象。
  缺点：无法实现动态组件，毕竟有些组件是运行时才决定的，或者加载的，无法在之前都建立起来。
  优点：框架实现简单。
2，建立严格的初始化先后顺序，如果发现服务不存在，立刻就出现错误。如果组件依赖于另外的组件，那么就需要在此之后初始化。
  缺点：无法实现真正的动态加载，另外严格的初始化顺序不一定实现，比如 menu 需要 dialog，dialog 也需要 menu，那么谁先谁后初始化？
3，组件在注册后，需要发送“服务已被注册”广播事件，比如menu通知“view.menu.add”服务上线了，需要注册自己菜单的，接到这个通知后，就注册。
  组件自己启动时，先查找是否存在“view.menu.add”服务，如果有再注册。
  优点：允许动态加载，无论先后顺序。
  缺点：组件的实现方式就比价复杂，需要允许重复发起请求。
4，从代理组件延伸，建立一套标准的接口，然后建立这些接口的组件实现，这些接口做为组件服务的中间层，屏蔽实现的细节。
  优点：可以规范实现。
  缺点：不利于扩展，再好的设计，也无法囊括未来所有的可能。

如果是双盲组件，按照现实生活中的方法，应该是在具有“共同认识”的前提下，阅读对方组件的说明，
然后分析如何使用，接着尝试调用是否正确。
最后评测各种方案，得到最优的结果。

所以建立中间、标准通信协议或组件是正确的实现方案，但是这种方案无法解决动态加载问题，只是解决了组件的通信标准问题。
动态加载有一个“简单的实现”，
5，当后期每次加入一个组件后，就调用其他组件的“初始化”方法。组件的初始化方法必须是可以重入的。

问题
---
1，在目前的架构中存在数据结构和画面、处理的区别，那么模型和算法在目前的框架中如何设计？
2，如何把功能都拆分出去？依据是什么？怎么作比较合理？
  按照基于对象的原理，应该将一个独立的功能做成一个对象，对象内部可以包含数据结构和对外的接口，屏蔽内部的实现机制和流程。
  如果对象内部的数据结构的细节需要暴露出去，那么这个设计就不够独立，如果内部的功能细节还需要外部了解才能使用，那么这个设计也是不够独立。
  应该在包裹的功能和数据基础上再建立更加高级的层次结构才是建立了独立的对象，也就是现在结构设计中的“组件”。
  
  反思一下菜单的设计，我想把菜单本身如何显示菜单、快捷方式等变成一个简单的接口：添加菜单，但是在实际的编写中发现，
  一个模块如果想添加菜单，不仅仅是调用一个“add”接口的问题，比如诸多菜单应该如何分组？点击了菜单后如何处理？
  我的思考是，菜单项目是有分组的，所以必须加入强的“规范”，作为菜单组件的一部分。
  至于点击菜单后的处理，不应该是菜单组件的一部分，菜单组件只能按照其他菜单请求显示的设定而发出被点击的信号，
  至于谁处理，应该是外部模块的机制，而不是菜单组件处理的。 那么谁处理？实际上，都是主窗口在处理，
  所以实际上应该是主窗口申请这个服务，然后自己根据菜单激活结果，注册具体如何实现！