Agile Relation Editor
====================

安装：
----
1. pip install prompt_toolkit
1. pip install CodernityDB
    这个是 Python 语言开发的，嵌入到程序中的NoSQL DB，是 key-value 类型。

目标：
----
  用特定的语法描述元素和它们之间的关系，然后可以显示、查询和编辑。
  需要符合我个人对于这个世界的各种理解方法：
  1. 所有的事务都称为对象。
    对象具有类别（类别也是对象），同样类别的对象具有同样的行为逻辑和特征值，当然具体对象具有具体的特征值。
    此软件可以根据类别建立具体对象，并且如规定的一样具有同样的行为逻辑和基本的特征值。
  2. 对象之间用特殊对象（称为：关系）相连。
    此软件可以建立对象和特殊关系，并进行设定。比如“继承”、“拥有”，这些都是特殊的关系，而不超出对象和关系的范围。
  3. 建立了关系的对象全体，可以称为模型。
    此软件可以建立模型，并进行显示、查询和修改。
    并且可以根据模型运行。<----------- 这个非常的重要。
  4. 对象之间可以不断的转换，是动态的。然后根据公式或者分析方法，演变成静态的关系公式。
    此软件可分析模型，并根据设定好的分析工具，分析关系和对象，变化成新的模型。
  
具体需求：
-------
0. 不用重复发明车轮，如果已经有好的实现就用，没有必要为了炫耀自己的技巧去实现一些东西。
1. 可以录入数据，能够符合大多数数据的要求。比如带有属性的对象，然后描述对象和对象之间的关系。
2. 可以以人的思维视角，去查询、改变数据。
    比如可视化操作，或者更加容易的操作。
        比如上一次的脚本存下来，对于结果和初始条件可以很容易的修改，边修改边看到答案。
    人容易理解的查询语句，而不是SQL、Python脚本之类基于底层实现的。
        就是按照人对一个事情的理解，可能会存在模糊和矛盾的地方，可以进行提示。
    可以通过描述要什么，而由程序自己选择算法来实现。
        比如我想去A，那么到A的途径就由程序来设计。这个不是安排好的算法，而是用AI进行启发的解决。
3. 可以将某个数据“依附”到其他的数据上，通过依附建立数据之间的关系。

目前想用到的应用场景是：数据分析（彩票分析）、程序关系（调用关系、静态关系等）、逻辑分析关系等。
  
设计方案：
-------
1. 元素(element)是此程序中所有的对象的统称。
    1. 元素必须具有唯一的内部ID，这样方便确认。这样有利于内部程序明确区别和保存。
1. 关系(relation)是元素之间的关系，实例必须关联两个以上对象。需要强调的是，关系也是元素。
    建立关系时，关系涉及到的元素和关系本身都需要验证是否符合要求，否则关系无法确立。
    1. 属性(property)是一种特殊关系。
        指依附于某个元素的元素，当属性依附的元素消失时，则属性消失。这个是简化“两个元素以属性关系相关”的说法。
    1. 包含(contain)是说：容器持有其他元素的引用，可以检索、移入移出被包含的元素。
        被包含的元素没有必要是同一个类型的。
    1. 类型（type）是两个元素之间的关系。
        一个元素1是另外一个元素2的类型，那么就是说元素2满足元素1的所有要求。
        在目前编程语言中，class是典型的类型，一般是元素1规定了需要实现的field和method，而元素2必须按照实现。
        1. 为了方便使用。针对添加类型，元素可以按照类型衍生出来。
            类型和元素之间的关系是“衍生”，正向和反向的称呼不同。
            类到元素是衍生，元素到类是继承。
   
具体的实现：
--------
1. App层，有App，功能主要是
    【这样设计的方案是，主要是建立命令执行和交互执行两种模式Mode】
    1. 解释命令行，然后创建 Parser + Container 模型，将参数传递给这两个。
    2. 解释命令，将“交互界面”的命令行传入到 Parser 中。
2. container层，有Parser + Container，功能主要是
    1. Parser：是控制整个程序的，包括Container。
        负责分析传入的命令，变成命令包(command package)，自己执行，或者发送给更下层的Control。
    1. Container:整个模型，包含若干的MVC。
        允许替换容器内的Model，以及当前的Model。
3. mvc层，包含Control + Model + View，功能主要是： 
3.1 Model：
    1. Element是基本的数据结构，包含Relation。
3.2 Control，是对MV的控制，但是只能控制配对Model内部。
    可以接受外部的命令包，然后根据Model的实际情况执行，推动View的更新。
3.3 View 是模型数据的体现，可以是显示的界面，日志输出，或者是文件输出。
4. Element和Relation的设计和实现
    Relation和Element之间功能的切分一定要清晰，因为目前没有多少实现的经验，所以还不知道怎么设计。

要点：
----
1. 设计成以上结构，是方便替换实现方法，但是会需要程序设计的非常精巧，这个尽量采用简单的实现方案吧。
1. 显示、存储需要和数据模型尽量分离开，因为这个程序的核心是“数据”，如何显示和怎么保存都会灵活变化。
1. 起点高一些吧，建立“领域语言”，并且可以进行编程。
   领域语言不一定是独立的解释、编译语言，可以是建立在某种特殊方法（比如早期建立在C的宏基础上的objective-c语言），
   或者就是一个复杂的类库，这样就不需要建立额外的语法了。

进度(要尽快！！！不要磨蹭，抓住空闲时间！)：
--------------------------------
1. -建立基本的运行结构，只要能够运行起来。-
2. 命令解析，放在后面做。仿效git的命令方式。
3. 目前的重点是数据的结构。
    1. 测试驱动：先写好需要执行的脚本，和产生的效果，然后再实现真正的逻辑。
4. 如果想建立统一的关系后，用任意UML图显示，那么就先要建立统一的UML关系。
    1. package/component/module/class/field or method
    2. 要不要考虑二级模型转化机制，就是一个通用的关系系统，然后将此关系系统转换成UML描述的关系，最后转换为显示的图。
        不过这个比较麻烦。目前编程语言是通过"对象继承"来实现复杂类型关系的，而转换则需要太多的层次结构，实现比较麻烦。
        另外一种方案是建立通用关系的定义，然后在此基础上建立更加具体和UML定义，用这个具体定义去描述系统，
        最后再生成UML。【目前是按照第二个方案进行的】
    3. 活动图和序列图都应该描述“函数”和“函数”之间的关系。

琐碎记录：
-------
如果建立比较通用的关系后，想建立更加具体或者复杂的关系，比如UML，那么应该建立某种更高级的规则，来描述 关系A=关系B+关系C之类的。
比如A是B的父类，B是C的父类，那么A也是C的父类。诸如此类。

1. 最基本的是“拥有”关系，比如"B--have-->foo"，就是“B拥有foo”。如果关系没有写就是缺省。
    关系有方向性，有前后关系。
2. 其他关系： A--调用-->B，是“A 调用 B”。
3. 组合关系： “A调用了B的foo函数” = ”B拥有foo函数，而A调用了foo“，如果再深究的话，那么A是无法直接调用函数的，所以”A拥有的bar和B拥有的foo函数之间是调用关系“。
    组合关系是说，将一些关系的组合，变成一个关系的统称。反过来，可以根据一个关系的统称，转化为一组关系。这个符合现代语言的定义。

就是说，以目前的情况看，不断扩展python的类比较困难，也不是长久之策，最好是允许在脚本中扩展类型。但是

1. 扩展类型可以，但是扩展类型具有的特定实现就很难。因为目前显示类图的工具不是简单的在graphiv上组合得到的。
2. 类型扩展目前受制于 UML 本身。
3. 最好是允许扩展“类型”，然后还可以针对特定的类型，指定的特定的实现。
