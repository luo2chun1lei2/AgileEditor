# 需求

1. 每个组件都可以对外提供服务，并调用其他组件的服务。
1. 组件的初始化没有先后顺序，如果有，那么必须提供依赖关系。
1. 组件尽量的独立，不需要知道太多其他组件的实现细节。
1. 组件应该可以组合，实现更加高级的功能。
1. 组件每个实例可以独立的运行，完成同类，但是不同对象的工作。比如都是编辑文件的组件，但是编辑的文件不同。
1. 在运行时，组件可以随意的添加、删除、修改。如果组件缺少需要的组件，允许无法动作。

# 设计

1. 组件对外提供service，可以被其它组件调用。需要注册到全局的“服务-组件表”中，允许多个组件提供一个同名服务。
1. 如果此服务被请求，那么就发送到所有注册的组件。组件内部自己通过参数来分析是否需要处理。
  允许“添加”和“删除”注册服务。
1. 组件可以使用其他组件提供的service。允许在“服务-组件表”中注册监视函数，一旦此服务被“添加或修改”，
  那么就重新调用服务。
1. 组件的初始化分成两步:
  1. 第一步是初始化自己，并将自己能够提供的服务注册到“服务-组件表”中，以及自己需要什么。需要监视某些服务，这些服务是“可选的服务”，有没有都可以，必须显示在菜单上。
  2. 第二步是正式运转，这里会“请求服务”，这些服务是必须的。
# 关键词
* 组件(cmp) 提供一组功能，且具有一定概念意义的一类实例的统称。
* 服务(svc) 对外提供的接口，可以被外部组件调用，实现某些功能。
* 监视(observe) 一直观察组件的某些特性，一旦此特性被改变，那么就会得到通知。
* 请求(request) 组件可以调用其他的组件的服务，这就叫做请求。

# 利用结构论，研究设计是否正确。

## 例子1
如果有一个组件cmp，有一个操作“注册”(reg)，功能是在 services 列表中加入一个cmp（允许重复），那么考察`P(l, f)`的结果。
l:无，f:services列表的结果，j:注册此cmp，不能有重复。
```
x = cmp.register
<x> = <cmp.register, cmp.register, ...> 长度从0开始到无限长度。
f(<>) = {services = <>}
f(<x>) = {services = <cmp> }
f(<x, x>) = {services = <cmp, cmp> }
f(<x, ...>, & len>2) = {services = <cmp, ...> & len=n}
```
类推得到 `f<x(n-1)>` 和 `f<xn>` 之间的关系: `f(<<x>, cmp.retgister>) = f(<x>).add(cmp)`

`j(f(<x, x>)) = False`，所以这种设计发现是**错误**的！
__证明错误，只需要一个例子就行__

重新设计：
cmp.register: 如果services中已经有cmp，那么就不再注册。
```
if cmp is not in services:
	services.add(cmp)
f(<>) = {services = <> }
f(<x>) = {services = <cmp> }
f(<x, x>) = {services = <cmp>}
f(<x, x, ...> & len>2) = {services = <cmp>}
```
虽然 `P={<>, <x>, ...}` 的元素有无穷多个，但是按照f的等效性来说，等同于 `{<>, <x>}`，所以 `P(f)= {<>, <x>}`，所以 `j( {f(P(f))} ) = True`，这个设计才是正确的。

__证明正确，必须考察全集__

## 例子2
如果有一个组件，有两个操作 reg 和 unreg，reg是将cmp注册到services中，如果已经存在，就不再添加。而unreg是在services中找到cmp，然后删除，如果不存在，就不进行任何动作。

l:无，f:services列表的结果，j:不能有重复的cmp，如果最后reg，services必须有cmp，如果最后unreg，services必须不包含cmp。
`x = cmp.reg，y = cmp.unreg`
`<xy>` : 由x和y组成的任意顺序和任意长度的序列。

看几种情况：
```
f(<>) = {services = <>}
f(<x>) = {services = <cmp>}
f(<y>) = {services = <>}
f(<x, y>) = {services = <>}
f(<y, x>) = {services = <cmp>}
```
需要总结 `P = {<x>, <y>, <x,y>, <y, x>, ...}`，P中的流程具有无限多，需要通过有效性来简化P的元素。

两种推论方法，

1. 第一种从任意队列开始：

   `<xy>`的序列可以切分成两个段`< <xy>, x>` 或者` < <xy>, y>`。

   `f(<xy>) = {<> or <cmp}`，因为无论经过什么操作，都只能得到这两种情况。
   用反证法证明，如果出现<cmp> & len>1的情况，那么调用什么操作都无法构成，所以不可能出现。

   * f(<<xy>, y>) = <>` 因为无论原来services是否为空，调用y后都会变成空。 **这里也符合j的要求**
   * `f(<<xy>, x>) = <cmp>` 因为无论原来services是否有元素，调用x都会变成有值。 **这里也符合j的要求**

   所以所有 `<<xy>, x>` 等效成 `<x>`， 所有`<<xy>, y>` 等效成` <y>`，那么得到 `P(f) = {<>, <x>, <y>}`，
   就有`j( {f(P(f))} ) = j( f({<>, <x>, <y>}) = True`。

2. 第二种从有限的开头开始推导：

   `<xy> & len=2` 的序列可以切分为两段

```
f(<x, x>) = {<cmp>}
f(<y, y>) = {<>}
f(<x, y>) = {<>}
f(<y, x>) = {<cmp>}
```
​	可以观察到，如果两个元素的序列`<?, ?>`效果取决于最后一个元素。所以
```
f(<xy>) = f( {<<?, x>, <xy>> or <<, y>, <xy>> }) = 
f( {<x, <xy>> or <y, <xy>>} ) = 
f( {<<?,x>, <xy>> or <<?, y>, <xy>>} ) ＝ 不断的递归简化后 = 
f( {<?, x> or <?, y>} ) = f({<x> or <y>}) = {<> or <cmp>}
```
​	__上面需要推导一个公式，看看是否可以将这种递推变成固定、明确的公式。__
	其实有　`f( <<xy>, x> ) = f(<x>) = {<cmp>}`
`f ( <<xy>, y> ) = f(<y>) = {<>}`
验证成功：`j( {f(P(f))} ) = j(f({<x>, <y>}) = True`

## 例子3
两个组件注册。有两个组件 cmp1 和 cmp2，其他都和上面相同。
`<xy>` 是任意队列，cmp1和cmp2 调用顺序和调用的函数都任意，调用次数任意。
cmp1 代表组件1的任意操作，cmp2代表组件2的任意操作。
	
```
f(<cmp1.?, cmp2.?>) = f(<cmp1.?>) + f(<cmp2.?>)
f(<cmp2.?, cmp1.?>) = f(<cmp2.?>) + f(<cmp1.?>)
```
观察得到，序列中cmp1的操作对于cmp2的结果无影响，所以可以
`f(<xy>) = f(<cmp1.xy>) + f(<cmp2.xy>) `
意思说，两个组件的操作流程可以拆分成两个组件各自的操作流程，且效果一样。 

**这个也应该是比较重要的推导原理。**
最后因为两个单独的序列都符合要求，所以`j(f)`也符合要求。

## 例子4
两个组件提供 svc 可以被其他的组件调用 `（cmp1.svc = z）`。
`j +=` 如果组件不存在，那么就出现错误！

首先查看一个序列 `<cmp1.svc>`，立刻发现因为cmp1没有register，所以就会出现错误。
那么这就需要加入形成序列的 限制 l。
`l = cmp1.svc after cmp1.reg`，序列中保证 `cmp1.reg` 后，`cmp1.svc`才能调用。cmp2同样。
那么将 P 的序列按照 l 删除后得到 `P(l)`。
这里也可以构造出一个错误序列 `<cmp1.reg, cmp1.unreg, cmp2.svc>`，cmp2 如果卸载了之前的注册，那么svc还会错误。

```
l = cmp1.svc after cmp1.reg before cmp2.unreg
```
虽然看起来好像没有问题，但是这个序列 `<cmp1.reg, cmp1.unreg, cmp1.reg, cmp1.svc>` 明显也是可以的，l 却过不去。

__这里就可以看到限制之前设定的比较随意，需要有严格的方法来规定怎么设置！__
__论证一般有两种情况，一种是自己其实已经知道怎么做，需要的是论证成功。另外一种是自己也不知道，需要通过讨论不断的分析得到需要什么样的设定。__

注意到，如果reg和unreg是随意排列的话，那么序列中必然存在调用svc会出现错误地方。
所以reg和unreg任意排列，和svc的任意放置，是矛盾的，只能存在一种任意排列，才能不出现错误。

因为上面的矛盾，所以必须修改一种设计，但是也可以扩展为修改其他的设计。

1. reg和unreg不得随意设定。
1. svc函数不得随意调用，必须在一个reg后面。
1. 允许svc调用时组件还没有被注册，也不出现错误，无法起作用。

根据现实情况，设定为“只要保证 cmp.svc 调用的前一个reg/unreg 是 reg 就可以了，因为最后一个cmp的reg/unreg才会起作用”。


